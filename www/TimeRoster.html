<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TimeRoster</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#3b82f6">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts Sammlung -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@300;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Verdana&display=swap" rel="stylesheet">

    <!-- Babel f√ºr JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "lucide-react": "https://esm.sh/lucide-react@0.294.0",
            "firebase/app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
            "firebase/auth": "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js",
            "firebase/firestore": "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js",
            "firebase/analytics": "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js",
            "firebase/messaging": "https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging.js"
        }
    }
    </script>

    <style>
        body {
            overscroll-behavior-y: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            background-color: #000000;
            margin: 0;
            padding: 0;
            color: white; /* Fallback Farbe erzwingen */
        }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        .font-cinzel { font-family: 'Cinzel', serif; }
        .font-msn { font-family: 'Verdana', sans-serif; }
        ::-webkit-scrollbar { width: 0px; background: transparent; }

        .msn-window {
            background: rgba(248, 250, 252, 0.92);
            border: 1px solid rgba(148, 163, 184, 0.4);
            box-shadow: 0 30px 80px rgba(15, 23, 42, 0.35);
            color: #0f172a;
            backdrop-filter: blur(18px);
            -webkit-backdrop-filter: blur(18px);
        }
        .msn-header {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 55%, #334155 100%);
            color: #f8fafc;
            text-shadow: 0 2px 6px rgba(15, 23, 42, 0.35);
        }
        .msn-toolbar {
            background: rgba(255, 255, 255, 0.75);
            border-bottom: 1px solid rgba(203, 213, 225, 0.7);
            color: #0f172a;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .msn-surface {
            background: rgba(255, 255, 255, 0.88);
            color: #0f172a;
        }
        .msn-status-online { background: radial-gradient(circle at 30% 30%, #a4ffa4, #008000); }
        .msn-status-offline { background: radial-gradient(circle at 30% 30%, #ffaaaa, #800000); }

        @keyframes pulse-soft {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.95); }
        }
        .animate-pulse-soft { animation: pulse-soft 1s infinite; }
        
        @keyframes blink-red {
            0%, 100% { color: #ef4444; opacity: 1; }
            50% { color: #dc2626; opacity: 0.7; }
        }
        .blink-red-notification {
            animation: blink-red 1.5s ease-in-out infinite;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-slate-950 text-white h-screen w-screen overflow-hidden">

    <div id="root" class="h-full w-full overflow-y-auto"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useMemo, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Calendar, List, Settings, Plus, X, ChevronLeft, ChevronRight, 
            MapPin, Bell, Repeat, Save, LogOut, Moon, Sun, Briefcase, Coffee, 
            CheckCircle, Play, Square, Award, Home, User, DollarSign, Plane, 
            Edit3, BarChart2, Mail, Lock, Trash2, Globe, Palette, Clock, Layout,
            FileText, MoreHorizontal, Type, ZoomIn, Users, Share2, Check, Eye, Eraser, Pencil,
            MessageCircle, Send, ArrowLeft, Camera, Image as ImageIcon, UserPlus, AlertCircle, Search,
            Download, Upload, Link2, Copy, UserCheck, Shield, Edit, FolderPlus, Paperclip
        } from 'lucide-react';

        import { initializeApp } from 'firebase/app';
        import { getAnalytics } from "firebase/analytics";
        import { 
            getAuth, signInAnonymously, onAuthStateChanged, signOut, 
            createUserWithEmailAndPassword, signInWithEmailAndPassword
        } from 'firebase/auth';
        import { 
            getFirestore, collection, doc, setDoc, addDoc, updateDoc, getDoc, getDocs,
            deleteDoc, onSnapshot, query, orderBy, where, serverTimestamp, writeBatch, limit, deleteField 
        } from 'firebase/firestore';
        import { getMessaging, getToken, onMessage } from 'firebase/messaging';

        // --- KONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyCLqi-PxHdeyt51u9i50tY0NhOAUbutW9g",
            authDomain: "calender-rai.firebaseapp.com",
            projectId: "calender-rai",
            storageBucket: "calender-rai.firebasestorage.app",
            messagingSenderId: "989981793002",
            appId: "1:989981793002:web:d23ba8bf2c30d6b8649593",
            measurementId: "G-CZLXPHK9GK"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = "timeroster-app";
        
        // --- NOTIFICATION CONSTANTS ---
        const NOTIFICATION_INDICATOR_CATEGORY = "Wissenswertes"; // Category that triggers notification indicator

        // --- HELPER FUNCTIONS ---
        const formatDate = (date) => date.toISOString().split('T')[0];
        const getDaysInMonth = (year, month) => new Date(year, month + 1, 0).getDate();
        const getFirstDayOfMonth = (year, month) => new Date(year, month, 1).getDay(); 

        const generateCode = () => {
            const digits = '0123456789';
            let result = 'rai';
            for (let i = 0; i < 6; i++) result += digits.charAt(Math.floor(Math.random() * digits.length));
            return result;
        };

        const getUserName = (user, overrideName) => (overrideName || user?.displayName || user?.email?.split('@')[0] || 'User');

        const compressImage = (file) => {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const MAX_WIDTH = 600;
                        const scaleSize = MAX_WIDTH / img.width;
                        canvas.width = MAX_WIDTH;
                        canvas.height = img.height * scaleSize;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        resolve(canvas.toDataURL('image/jpeg', 0.7));
                    }
                }
            });
        };

        // --- WEATHER (Open-Meteo) ---
        // Uses Open-Meteo Weather Forecast API (no API key). Current weather variables via `current=`.
        // Docs: https://open-meteo.com/en/docs
        const WEATHER_CACHE_KEY = "timeroster_weather_cache_v1";
        const WEATHER_CACHE_TTL_MS = 30 * 60 * 1000; // 30 min
        const DEFAULT_WEATHER_COORDS = { lat: 47.3769, lon: 8.5417, label: "Z√ºrich (Fallback)" }; // Zurich

        const getWeatherMeta = (code) => {
            const c = Number(code);
            if (c === 0) return { label: "Klar", icon: "‚òÄÔ∏è" };
            if ([1,2].includes(c)) return { label: "Leicht bew√∂lkt", icon: "üå§Ô∏è" };
            if (c === 3) return { label: "Bedeckt", icon: "‚òÅÔ∏è" };
            if ([45,48].includes(c)) return { label: "Nebel", icon: "üå´Ô∏è" };
            if ([51,53,55,56,57].includes(c)) return { label: "Niesel", icon: "üå¶Ô∏è" };
            if ([61,63,65,66,67].includes(c)) return { label: "Regen", icon: "üåßÔ∏è" };
            if ([71,73,75,77,85,86].includes(c)) return { label: "Schnee", icon: "üå®Ô∏è" };
            if ([80,81,82].includes(c)) return { label: "Schauer", icon: "üå¶Ô∏è" };
            if ([95,96,99].includes(c)) return { label: "Gewitter", icon: "‚õàÔ∏è" };
            return { label: "Wetter", icon: "üå°Ô∏è" };
        };

        const buildWeatherUrl = (lat, lon) => {
            const tz = "Europe/Zurich";
            const params = new URLSearchParams({
                latitude: String(lat),
                longitude: String(lon),
                current: "temperature_2m,weather_code,wind_speed_10m",
                wind_speed_unit: "kmh",
                temperature_unit: "celsius",
                timezone: tz
            });
            return `https://api.open-meteo.com/v1/forecast?${params.toString()}`;
        };

        const buildGeocodeUrl = (name) => {
            const params = new URLSearchParams({
                name: String(name || ""),
                count: "8",
                language: "de",
                format: "json"
            });
            return `https://geocoding-api.open-meteo.com/v1/search?${params.toString()}`;
        };

        const getWeatherPrefKey = (uid) => `timeroster_weather_pref_v1_${uid || "anon"}`;
        const getUiPrefKey = (uid) => `timeroster_ui_prefs_v1_${uid || "anon"}`;


        // --- DAILY QUOTES (Weisheit / Motivation / Kompliment / Wissenswertes) ---
        // Kurz, alltagstauglich. Ein Mix aus Sprichw√∂rtern (gemeinfrei) und kurzen Original-Lines.
        const QUOTE_BANK = {
            wisdom: [
                { text: "Wer langsam geht, kommt auch an.", origin: "Sprichwort (Europa)" },
                { text: "Geduld ist auch eine Form von St√§rke.", origin: "Sprichwort (Asien)" },
                { text: "Der beste Zeitpunkt ist meistens jetzt.", origin: "Moderne Weisheit" },
                { text: "Ein ruhiger Geist sieht weiter.", origin: "Sprichwort (Japan)" },
                { text: "Worte sind leicht ‚Äì Handlungen z√§hlen.", origin: "Sprichwort (Afrika)" },
                { text: "Kleine Schritte schlagen grosse Absichten.", origin: "Sprichwort (Schweiz)" },
                { text: "Man kann den Wind nicht √§ndern, aber die Segel.", origin: "Sprichwort (Nordeuropa)" },
                { text: "Wer fragt, verliert nicht.", origin: "Sprichwort (DACH)" },
                { text: "Ein guter Plan lebt von Anpassung.", origin: "Operations-Realit√§t" },
                { text: "Ein klares Nein sch√ºtzt ein sauberes Ja.", origin: "Moderne Weisheit" },
                { text: "Wenn du es erkl√§ren kannst, hast du es verstanden.", origin: "Alltagsweisheit" },
                { text: "Ordnung schafft Freiheit.", origin: "Sprichwort (Mitteleuropa)" },
                { text: "Der Weg ist das Ziel ‚Äì aber der Kurs muss stimmen.", origin: "Moderne Weisheit" },
                { text: "Wer zuh√∂rt, versteht schneller.", origin: "Sprichwort (Global)" },
                { text: "Ein Fehler ist ein Hinweis, kein Urteil.", origin: "Moderne Weisheit" },
                { text: "Klarheit entsteht durch Entscheidungen.", origin: "Business-Realit√§t" },
                { text: "Was du misst, kannst du steuern.", origin: "Management-Weisheit" },
                { text: "Ein ruhiger Start spart sp√§ter Hektik.", origin: "Sprichwort (Schweiz)" },
                { text: "Nicht alles, was z√§hlt, ist laut.", origin: "Moderne Weisheit" },
                { text: "Sorgfalt ist Geschwindigkeit in Verkleidung.", origin: "Operations-Weisheit" }
            ],
            motivation: [
                { text: "Heute z√§hlt. Nicht irgendwann.", origin: "Motivation (Global)" },
                { text: "Du brauchst keinen perfekten Start ‚Äì nur den ersten Schritt.", origin: "Motivation (Global)" },
                { text: "Konsequenz schl√§gt Intensit√§t.", origin: "Motivation (Work)" },
                { text: "Mach's klein genug, dass du nicht aussteigst.", origin: "Motivation (Produktivit√§t)" },
                { text: "Wenn es unbequem ist, w√§chst du.", origin: "Motivation (Global)" },
                { text: "Fortschritt ist ein System, kein Zufall.", origin: "Motivation (Business)" },
                { text: "Du bist n√§her dran als du denkst.", origin: "Motivation (Global)" },
                { text: "Fokus ist ein Wettbewerbsvorteil.", origin: "Motivation (Business)" },
                { text: "Ein guter Tag beginnt mit einer klaren Priorit√§t.", origin: "Motivation (Work)" },
                { text: "Du steuerst den Kurs ‚Äì nicht den Wind.", origin: "Motivation (Seefahrt)" },
                { text: "Heute sauber arbeiten, morgen weniger Stress.", origin: "Motivation (Operations)" },
                { text: "Du darfst stolz auf deinen Effort sein.", origin: "Motivation (Global)" },
                { text: "Ein Schritt mehr als gestern ist genug.", origin: "Motivation (Global)" },
                { text: "Mach's einfach ‚Äì aber mach's zuverl√§ssig.", origin: "Motivation (Operations)" },
                { text: "Der Start ist schwer, der Rhythmus tr√§gt.", origin: "Motivation (Global)" },
                { text: "Disziplin ist Selbstrespekt in Aktion.", origin: "Motivation (Global)" },
                { text: "Du kannst das Tempo w√§hlen ‚Äì Hauptsache vorw√§rts.", origin: "Motivation (Global)" },
                { text: "Qualit√§t entsteht nicht durch Zufall, sondern durch Standards.", origin: "Motivation (Business)" },
                { text: "Eine Entscheidung pro Tag ver√§ndert ein Jahr.", origin: "Motivation (Global)" },
                { text: "Bleib bei deinem Prozess ‚Äì Resultate folgen.", origin: "Motivation (Business)" }
            ],
            compliment: [
                { text: "Du wirkst wie jemand, der Dinge wirklich zu Ende bringt.", origin: "Kompliment (Global)" },
                { text: "Deine Ruhe ist sp√ºrbar ‚Äì und wirkt ansteckend.", origin: "Kompliment (Global)" },
                { text: "Du denkst strukturiert. Das ist selten.", origin: "Kompliment (Business)" },
                { text: "Du bist verl√§sslich ‚Äì das ist Gold wert.", origin: "Kompliment (Work)" },
                { text: "Du hast ein gutes Auge f√ºr Details.", origin: "Kompliment (Global)" },
                { text: "Du bringst Klarheit in komplexe Themen.", origin: "Kompliment (Business)" },
                { text: "Du h√§ltst dein Wort. Das schafft Vertrauen.", origin: "Kompliment (Global)" },
                { text: "Du machst es anderen leichter ‚Äì ohne grosses Theater.", origin: "Kompliment (Schweiz)" },
                { text: "Du setzt Priorit√§ten wie ein Profi.", origin: "Kompliment (Operations)" },
                { text: "Du bist konsequent. Das sieht man.", origin: "Kompliment (Global)" },
                { text: "Du bist nicht laut ‚Äì aber wirkungsvoll.", origin: "Kompliment (Global)" },
                { text: "Du machst Qualit√§t sichtbar.", origin: "Kompliment (Work)" },
                { text: "Dein Anspruch an Sauberkeit ist sp√ºrbar.", origin: "Kompliment (Operations)" },
                { text: "Du bleibst dran, auch wenn's z√§h ist.", origin: "Kompliment (Global)" },
                { text: "Du schaffst Vertrauen durch Konstanz.", origin: "Kompliment (Business)" },
                { text: "Du hast ein gutes Timing f√ºr Entscheidungen.", origin: "Kompliment (Work)" },
                { text: "Du bringst Ordnung in Chaos ‚Äì diskret und effizient.", origin: "Kompliment (Business)" },
                { text: "Du bist l√∂sungsorientiert, nicht ausredeorientiert.", origin: "Kompliment (Work)" },
                { text: "Du kommunizierst klar ‚Äì das spart allen Zeit.", origin: "Kompliment (Business)" },
                { text: "Du hast eine starke Pr√§senz, ohne dich aufzudr√§ngen.", origin: "Kompliment (Global)" }
            ],
            fact: [
                { text: "Ein Tag auf der Venus ist l√§nger als ein Venusjahr.", origin: "Wissenswertes (Astronomie)" },
                { text: "Oktopusse haben drei Herzen.", origin: "Wissenswertes (Biologie)" },
                { text: "Honig kann bei guter Lagerung extrem lange haltbar sein.", origin: "Wissenswertes (Lebensmittel)" },
                { text: "Die Schweiz hat vier Landessprachen.", origin: "Wissenswertes (Schweiz)" },
                { text: "Ein Blitz kann heisser sein als die Oberfl√§che der Sonne.", origin: "Wissenswertes (Physik)" },
                { text: "Bienen kommunizieren u. a. √ºber einen 'Schw√§nzeltanz'.", origin: "Wissenswertes (Biologie)" },
                { text: "Wasser dehnt sich beim Gefrieren aus ‚Äì deshalb schwimmt Eis.", origin: "Wissenswertes (Physik)" },
                { text: "Dein Gehirn verbraucht rund 20% der Energie im Ruhezustand.", origin: "Wissenswertes (Biologie)" },
                { text: "Die Luft enth√§lt etwa 78% Stickstoff.", origin: "Wissenswertes (Chemie)" },
                { text: "Ein Tag hat 86'400 Sekunden.", origin: "Wissenswertes (Zeit)" },
                { text: "Der l√§ngste Fluss Europas ist die Wolga.", origin: "Wissenswertes (Geografie)" },
                { text: "Der Eiffelturm dehnt sich bei Hitze messbar aus.", origin: "Wissenswertes (Materialkunde)" },
                { text: "Wale schlafen, indem sie jeweils eine Gehirnh√§lfte ruhen lassen.", origin: "Wissenswertes (Biologie)" },
                { text: "Banenen sind botanisch gesehen Beeren.", origin: "Wissenswertes (Botanik)" },
                { text: "Das Herz schl√§gt im Schnitt etwa 100'000 Mal pro Tag.", origin: "Wissenswertes (Medizin)" },
                { text: "Ein Regenbogen ist ein optisches Ph√§nomen durch Brechung und Reflexion.", origin: "Wissenswertes (Physik)" },
                { text: "Die meisten Vulkane liegen entlang von Plattengrenzen.", origin: "Wissenswertes (Geologie)" },
                { text: "Der menschliche K√∂rper besteht zu rund 60% aus Wasser.", origin: "Wissenswertes (Biologie)" },
                { text: "Kaffee enth√§lt u. a. √ºber 800 Aromastoffe.", origin: "Wissenswertes (Lebensmittel)" },
                { text: "Der Mount Everest w√§chst jedes Jahr um wenige Millimeter.", origin: "Wissenswertes (Geologie)" }
            ]
        };

        const hashStr = (s) => {
            // FNV-1a 32-bit
            let h = 0x811c9dc5;
            for (let i = 0; i < s.length; i++) {
                h ^= s.charCodeAt(i);
                h = Math.imul(h, 0x01000193);
            }
            return (h >>> 0);
        };

        const getDailyQuote = (dateStr, uid) => {
            const cats = [
                { key: "wisdom", label: "Weisheit" },
                { key: "motivation", label: "Motivation" },
                { key: "compliment", label: "Kompliment" },
                { key: "fact", label: "Wissenswertes" }
            ];
            const [y, m, d] = String(dateStr || "").split("-").map(x => parseInt(x, 10));
            const dayIndex = Math.floor(new Date(y, (m || 1) - 1, d || 1).getTime() / 86400000);
            const cat = cats[((dayIndex % cats.length) + cats.length) % cats.length];
            const list = QUOTE_BANK[cat.key] || [];
            const pick = list.length ? (hashStr(`${dateStr}|${uid}|${cat.key}`) % list.length) : 0;
            const item = list[pick] || { text: "Heute ist ein guter Tag f√ºr einen guten Schritt.", origin: "Global" };
            return { category: cat.label, ...item };
        };



        // FIX: fehlende Funktion (war Hauptursache f√ºr "Black Screen" nach Login)
        const parseYMD = (s) => {
            const parts = String(s || '').split('-').map(n => parseInt(n, 10));
            if (parts.length !== 3 || parts.some(n => Number.isNaN(n))) return null;
            const [y, m, d] = parts;
            return { y, m, d, date: new Date(y, m - 1, d) };
        };

        const matchesRecurrence = (ev, targetDateStr) => {
            if (!ev || !ev.date) return false;
            const rep = (ev.repeat || 'none');
            if (rep === 'none') return ev.date === targetDateStr;

            const start = parseYMD(ev.date);
            const target = parseYMD(targetDateStr);
            if (!start || !target) return false;

            // Only apply recurrence on/after the start date
            if (target.date.getTime() < start.date.getTime()) return false;

            if (rep === 'daily') return true;

            if (rep === 'weekly') {
                return target.date.getDay() === start.date.getDay();
            }

            if (rep === 'monthly') {
                return target.d === start.d;
            }

            if (rep === 'yearly') {
                return target.m === start.m && target.d === start.d;
            }

            return ev.date === targetDateStr;
        };

        const getEventsForDate = (dateStr, eventsArr) => {
            if (!Array.isArray(eventsArr)) return [];
            return eventsArr
                .filter(ev => ev && (ev.date === dateStr || matchesRecurrence(ev, dateStr)))
                .sort((a, b) => (a.time || '').localeCompare(b.time || ''));
        };

        // --- CALENDAR & ICS HELPERS ---
        
        // Generate unique calendar ID
        const generateCalendarId = () => `cal_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
        
        // Generate secure token for public/subscription links
        const generateSecureToken = () => {
            const array = new Uint8Array(24);
            window.crypto.getRandomValues(array);
            return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
        };
        
        // Format date/time for ICS format (YYYYMMDDTHHMMSSZ)
        const formatICSDateTime = (dateStr, timeStr = '00:00') => {
            const [year, month, day] = dateStr.split('-');
            const [hour, minute] = timeStr.split(':');
            return `${year}${month}${day}T${hour.padStart(2,'0')}${minute.padStart(2,'0')}00`;
        };
        
        // Escape text for ICS format
        const escapeICSText = (text) => {
            if (!text) return '';
            return text.replace(/\\/g, '\\\\')
                      .replace(/;/g, '\\;')
                      .replace(/,/g, '\\,')
                      .replace(/\n/g, '\\n');
        };
        
        // Generate ICS file content from events
        const generateICS = (events, calendarName = 'TimeRoster Calendar') => {
            const lines = [
                'BEGIN:VCALENDAR',
                'VERSION:2.0',
                'PRODID:-//TimeRoster//Calendar Export//EN',
                `X-WR-CALNAME:${escapeICSText(calendarName)}`,
                'X-WR-TIMEZONE:Europe/Berlin',
                'CALSCALE:GREGORIAN',
                'METHOD:PUBLISH'
            ];
            
            events.forEach(event => {
                const uid = `${event.id}@timeroster.app`;
                const dtstart = formatICSDateTime(event.date, event.time || '00:00');
                
                // Calculate end time (1 hour after start), handling day boundary
                const [hour, minute] = (event.time || '00:00').split(':');
                const hourInt = parseInt(hour);
                const endHour = hourInt >= 23 ? '00' : String(hourInt + 1).padStart(2, '0');
                const dtend = formatICSDateTime(event.date, `${endHour}:${minute}`);
                
                const now = new Date();
                const dtstamp = formatICSDateTime(now.toISOString().split('T')[0], now.toTimeString().substring(0, 5));
                
                lines.push('BEGIN:VEVENT');
                lines.push(`UID:${uid}`);
                lines.push(`DTSTAMP:${dtstamp}`);
                lines.push(`DTSTART:${dtstart}`);
                lines.push(`DTEND:${dtend}`);
                lines.push(`SUMMARY:${escapeICSText(event.title)}`);
                
                if (event.location) {
                    lines.push(`LOCATION:${escapeICSText(event.location)}`);
                }
                
                if (event.category) {
                    lines.push(`CATEGORIES:${escapeICSText(event.category)}`);
                }
                
                // Handle recurring events
                if (event.repeat && event.repeat !== 'none') {
                    const freqMap = {
                        'daily': 'DAILY',
                        'weekly': 'WEEKLY',
                        'monthly': 'MONTHLY',
                        'yearly': 'YEARLY'
                    };
                    if (freqMap[event.repeat]) {
                        lines.push(`RRULE:FREQ=${freqMap[event.repeat]}`);
                    }
                }
                
                lines.push('END:VEVENT');
            });
            
            lines.push('END:VCALENDAR');
            return lines.join('\r\n');
        };
        
        // Download ICS file
        const downloadICS = (icsContent, filename = 'calendar.ics') => {
            const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        };

        // --- TRANSLATIONS ---
        const t = (key) => {
            const map = {
dashboard: "√úbersicht", calendar: "Kalender", friends: "Freunde", settings: "Einstellungen",
                newEvent: "Ereignis", title: "Info", category: "Kategorie", save: "Speichern", cancel: "Abbrechen",
                delete: "L√∂schen", edit: "Bearbeiten", details: "Details",
                messenger: "MSN Messenger", contacts: "Kontakte", online: "Online", offline: "Offline",
                addContact: "Kontakt hinzuf√ºgen", requests: "Anfragen", accept: "Annehmen", myCode: "Mein Code",
                typeHere: "Nachricht eingeben...", send: "Senden", photo: "Foto",
                signIn: "Login", register: "Reg.", email: "E-Mail", password: "Passwort", guest: "Gastzugang", or: "oder",
                pendingRequests: "Offene Anfragen", myFriends: "Meine Freunde", backToMe: "Zur√ºck zu mir", viewing: "Ansichtsmodus",
                addFriend: "Freund per Code adden", shareCode: "Dein Freundes-Code",
                work: "Arbeit", personal: "Privat", health: "Gesundheit", household: "Haushalt", leisure: "Freizeit",
                editEvent: "Ereignis bearbeiten", eventDetails: "Details",
                dayOptions: "Optionen", assignShift: "Schicht zuweisen", createEvent: "Ereignis (+)", clearShift: "Schicht l√∂schen",
                paintMode: "Pinsel", font: "Schriftart", fontSize: "Gr√∂√üe", manageShifts: "Schichten verwalten",
                appearance: "Design", selectShift: "Schicht w√§hlen", save: "Speichern", newShift: "Neue Schicht",
                start: "Start", end: "Ende", color: "Farbe", shiftName: "Name",
                fontModern: "Modern", fontAntique: "Antik", fontElegant: "Elegant", fontReadable: "Lesbar", fontStrong: "Stark",
                repeat: "Wiederholung", repeatNone: "Nie", repeatDaily: "T√§glich", repeatWeekly: "W√∂chentlich", repeatMonthly: "Monatlich", repeatYearly: "J√§hrlich",
                offDuty: "Frei",
                noble: "Noble",
                comic: "Comic",
                amoled: "AMOLED",
                mono: "Schwarz/Weiss",
                upcoming: "Anstehend",
                birthday: "Geburtstag",
                rangeWeek: "Woche",
                rangeMonth: "Monat",
                rangeYear: "Jahr",
                noUpcoming: "Keine Ereignisse im gew√§hlten Zeitraum.",
                viewDay: "Tag",
                viewWeek: "Woche",
                viewMonth: "Monat",
                location: "Ort",
                timezone: "Zeitzone",
                search: "Suchen",
                searchPlaceholder: "Ereignis suchen...",
                searchResults: "Suchergebnisse",
                noResults: "Keine Ereignisse gefunden.",
                clearSearch: "Zur√ºck",
                pleaseEnterName: "Bitte einen Namen eingeben.",
                noEventsToExport: "Keine Events zum Exportieren.",
                sharingRequiresEmailLookup: "Sharing-Funktion erfordert E-Mail-Suche. Verwenden Sie einen √∂ffentlichen Link.",
                calendarNotFound: "Kalender nicht gefunden.",
                onlyOwnerCanChangeSettings: "Nur der Eigent√ºmer kann diese Einstellung √§ndern.",
                manageCalendars: "Kalender verwalten",
                shareCalendar: "Kalender teilen",
                myCalendars: "Meine Kalender",
                calendarOwner: "Eigent√ºmer",
                calendarMember: "Mitglied",
                // Task Management
                tasks: "Aufgaben",
                addTask: "Aufgabe hinzuf√ºgen",
                taskTitle: "Aufgabentitel",
                dueDate: "F√§lligkeitsdatum",
                responsible: "Verantwortlich",
                status: "Status",
                priority: "Priorit√§t",
                checklist: "Checkliste",
                addSubtask: "Unterpunkt hinzuf√ºgen",
                subtask: "Unterpunkt",
                statusOpen: "Offen",
                statusInProgress: "In Arbeit",
                statusCompleted: "Erledigt",
                priorityHigh: "Wichtig",
                priorityNormal: "Normal",
                priorityLow: "Niedrig",
                taskReminder: "Aufgaben-Erinnerung",
                noTasks: "Keine Aufgaben",
                deleteTask: "Aufgabe l√∂schen",
                unassigned: "Nicht zugewiesen",
                name: "Name",
                invitees: "Teilnehmer",
                inviteParticipants: "Teilnehmer einladen (nur Freunde)",
                organizer: "Organisator",
                going: "Zusage",
                maybe: "Vielleicht",
                declined: "Absage",
                noResponse: "Keine Antwort",
            };

            return map[key] || key;
        };

        const CATEGORIES = [
{ id: 'work', name: 'Arbeit', icon: 'üíº', color: '#f59e0b' },
            { id: 'personal', name: 'Privat', icon: 'üë§', color: '#3b82f6' },
            { id: 'birthday', name: 'Geburtstag', icon: 'üéÇ', color: '#ec4899' },
            { id: 'health', name: 'Gesundheit', icon: '‚ù§Ô∏è', color: '#ef4444' },
            { id: 'household', name: 'Haushalt', icon: 'üè†', color: '#10b981' },
            { id: 'leisure', name: 'Freizeit', icon: 'üéâ', color: '#8b5cf6' },
        ];

        const DEFAULT_SHIFTS = [
            { id: 'early', name: 'Fr√ºh', start: '06:00', end: '14:00', color: '#10b981' }, 
            { id: 'late', name: 'Sp√§t', start: '14:00', end: '22:00', color: '#f59e0b' }, 
            { id: 'night', name: 'Nacht', start: '22:00', end: '06:00', color: '#6366f1' }, 
            { id: 'off', name: 'Frei', start: '-', end: '-', color: '#9ca3af' } 
        ];

        const TIMEZONES = [
            'UTC', 'Europe/Berlin', 'Europe/Zurich', 'Europe/Vienna', 'Europe/London',
            'America/New_York', 'America/Los_Angeles', 'America/Chicago', 'Asia/Tokyo',
            'Asia/Shanghai', 'Asia/Dubai', 'Australia/Sydney', 'Pacific/Auckland'
        ];

        // --- END-TO-END ENCRYPTION (Web Crypto API) ---
        // Uses AES-GCM for encryption with ECDH for key exchange
        const E2EE = {
            // Generate a new key pair for the user
            async generateKeyPair() {
                return await crypto.subtle.generateKey(
                    { name: "ECDH", namedCurve: "P-256" },
                    true,
                    ["deriveKey", "deriveBits"]
                );
            },

            // Export public key to Base64
            async exportPublicKey(publicKey) {
                const exported = await crypto.subtle.exportKey("spki", publicKey);
                return btoa(String.fromCharCode(...new Uint8Array(exported)));
            },

            // Import public key from Base64
            async importPublicKey(base64Key) {
                const binary = atob(base64Key);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                return await crypto.subtle.importKey(
                    "spki",
                    bytes.buffer,
                    { name: "ECDH", namedCurve: "P-256" },
                    true,
                    []
                );
            },

            // Export private key to Base64
            async exportPrivateKey(privateKey) {
                const exported = await crypto.subtle.exportKey("pkcs8", privateKey);
                return btoa(String.fromCharCode(...new Uint8Array(exported)));
            },

            // Import private key from Base64
            async importPrivateKey(base64Key) {
                const binary = atob(base64Key);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                return await crypto.subtle.importKey(
                    "pkcs8",
                    bytes.buffer,
                    { name: "ECDH", namedCurve: "P-256" },
                    true,
                    ["deriveKey", "deriveBits"]
                );
            },

            // Derive shared secret from key pair
            async deriveSharedSecret(privateKey, publicKey) {
                return await crypto.subtle.deriveKey(
                    { name: "ECDH", public: publicKey },
                    privateKey,
                    { name: "AES-GCM", length: 256 },
                    true,
                    ["encrypt", "decrypt"]
                );
            },

            // Encrypt message with AES-GCM
            async encrypt(text, sharedSecret) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encoded = new TextEncoder().encode(text);
                const encrypted = await crypto.subtle.encrypt(
                    { name: "AES-GCM", iv },
                    sharedSecret,
                    encoded
                );
                // Return IV + encrypted data as Base64
                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv, 0);
                combined.set(new Uint8Array(encrypted), iv.length);
                return btoa(String.fromCharCode(...combined));
            },

            // Decrypt message with AES-GCM
            async decrypt(encryptedBase64, sharedSecret) {
                try {
                    const binary = atob(encryptedBase64);
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                    
                    const iv = bytes.slice(0, 12);
                    const data = bytes.slice(12);
                    
                    const decrypted = await crypto.subtle.decrypt(
                        { name: "AES-GCM", iv },
                        sharedSecret,
                        data
                    );
                    return new TextDecoder().decode(decrypted);
                } catch (e) {
                    console.error("Decryption error:", e);
                    return "[Entschl√ºsselung fehlgeschlagen]";
                }
            },

            // For group conversations: encrypt for multiple recipients
            async encryptForGroup(text, sharedSecrets) {
                const encrypted = {};
                for (const [userId, secret] of Object.entries(sharedSecrets)) {
                    encrypted[userId] = await this.encrypt(text, secret);
                }
                return encrypted;
            }
        };

        // --- SECRET MSN NACHRICHTEN (Modern UI + MSN Presence + Avatar Upload) ---
        const INITIAL_MESSAGE_LIMIT = 50;
        const MESSAGE_BATCH_SIZE = 50;
        const INPUT_REFOCUS_DELAY = 50;
        
        const SecretMsnMessages = ({ user, onClose }) => {
            const [view, setView] = useState('list'); // list | add | message | profile | friendProfile | createGroup
            const [contacts, setContacts] = useState([]);
            const [groups, setGroups] = useState([]);
            const [activeConversation, setActiveConversation] = useState(null);
            const [messages, setMessages] = useState([]);
            const [input, setInput] = useState('');
            const [myCode, setMyCode] = useState('');
            const [addCode, setAddCode] = useState('');
            const [requests, setRequests] = useState([]);
            const [profile, setProfile] = useState({ username: '', avatar: '', statusText: '', bio: '' });
            const [avatarZoom, setAvatarZoom] = useState(null); // { src, name }
            const [savingProfile, setSavingProfile] = useState(false);
            const [messageLimit, setMessageLimit] = useState(INITIAL_MESSAGE_LIMIT);
            const [hasMoreMessages, setHasMoreMessages] = useState(false);
            const scrollRef = useRef();
            const inputRef = useRef();
            const [editingMessage, setEditingMessage] = useState(null);
            const [replyingTo, setReplyingTo] = useState(null);
            const [friendSortMode, setFriendSortMode] = useState(() => localStorage.getItem('msn_friend_sort') || 'status');
            const [viewingFriendProfile, setViewingFriendProfile] = useState(null);
            const [myKeys, setMyKeys] = useState(null); // { publicKey, privateKey }
            const [sharedSecrets, setSharedSecrets] = useState({}); // { friendId: sharedSecret }
            const [messageExpiry, setMessageExpiry] = useState('24h'); // '24h', '7d', 'never'
            const [readOnceMode, setReadOnceMode] = useState(false);
            const [groupName, setGroupName] = useState('');
            const [selectedGroupMembers, setSelectedGroupMembers] = useState([]);
            const [messagesDarkMode, setMessagesDarkMode] = useState(() => {
                try {
                    return localStorage.getItem('msn_messages_dark_mode') === 'true';
                } catch {
                    return false;
                }
            });
            const [cameraOpen, setCameraOpen] = useState(false);
            const [cameraStream, setCameraStream] = useState(null);
            const videoRef = useRef();
            const canvasRef = useRef();

            // Helper function to safely convert timestamps
            const toMillis = (timestamp) => {
                if (!timestamp) return 0;
                if (typeof timestamp === 'number') return timestamp;
                if (timestamp.toMillis) return timestamp.toMillis();
                if (timestamp instanceof Date) return timestamp.getTime();
                return 0;
            };

            const avatarSrc = (uid, avatar) => {
                if (avatar && String(avatar).trim().length > 0) return avatar;
                return `https://api.dicebear.com/7.x/pixel-art/svg?seed=${encodeURIComponent(uid)}`;
            };

            // Save dark mode preference
            useEffect(() => {
                try {
                    localStorage.setItem('msn_messages_dark_mode', messagesDarkMode);
                } catch (e) {
                    console.error('Failed to save dark mode preference:', e);
                }
            }, [messagesDarkMode]);

            useEffect(() => {
                const updatePresence = async () => {
                    try {
                        const profileRef = doc(db, 'artifacts', appId, 'users', user.uid, 'secret_msn_profile', 'main');
                        const snap = await getDoc(profileRef);
                        let code = '';
                        let keys = myKeys;
                        
                        if (!snap.exists()) {
                            code = generateCode();
                            const username = user.email?.split('@')[0] || "Gast";
                            
                            // Generate encryption keys
                            const keyPair = await E2EE.generateKeyPair();
                            const publicKeyB64 = await E2EE.exportPublicKey(keyPair.publicKey);
                            const privateKeyB64 = await E2EE.exportPrivateKey(keyPair.privateKey);
                            keys = { publicKey: keyPair.publicKey, privateKey: keyPair.privateKey };
                            setMyKeys(keys);
                            
                            const base = { 
                                shareCode: code, 
                                username, 
                                avatar: '', 
                                statusText: '', 
                                bio: '', 
                                status: 'online', 
                                lastSeen: serverTimestamp(),
                                publicKey: publicKeyB64,
                                privateKey: privateKeyB64 // Store encrypted in production
                            };
                            await setDoc(profileRef, base);
                            await setDoc(doc(db, 'artifacts', appId, 'secret_public_codes', code), { userId: user.uid });
                            setProfile({ username, avatar: '', statusText: '', bio: '' });
                        } else {
                            const data = snap.data() || {};
                            code = data.shareCode || generateCode();
                            
                            // Load encryption keys
                            if (data.publicKey && data.privateKey) {
                                const publicKey = await E2EE.importPublicKey(data.publicKey);
                                const privateKey = await E2EE.importPrivateKey(data.privateKey);
                                keys = { publicKey, privateKey };
                                setMyKeys(keys);
                            } else {
                                // Generate keys if missing
                                const keyPair = await E2EE.generateKeyPair();
                                const publicKeyB64 = await E2EE.exportPublicKey(keyPair.publicKey);
                                const privateKeyB64 = await E2EE.exportPrivateKey(keyPair.privateKey);
                                keys = { publicKey: keyPair.publicKey, privateKey: keyPair.privateKey };
                                setMyKeys(keys);
                                await updateDoc(profileRef, { 
                                    publicKey: publicKeyB64,
                                    privateKey: privateKeyB64
                                });
                            }
                            
                            await updateDoc(profileRef, { lastSeen: serverTimestamp(), status: 'online' });
                            setProfile({
                                username: data.username || (user.email?.split('@')[0] || "Gast"),
                                avatar: data.avatar || '',
                                statusText: data.statusText || '',
                                bio: data.bio || ''
                            });
                        }
                        setMyCode(code);
                    } catch(e) { console.error("MSN Presence Error", e); }
                };
                updatePresence();
                const interval = setInterval(updatePresence, 60000);
                return () => clearInterval(interval);
            }, [user]);

            useEffect(() => {
                const q = collection(db, 'artifacts', appId, 'users', user.uid, 'secret_contacts');
                const unsub = onSnapshot(q, async (snap) => {
                    const list = [];
                    for (const d of snap.docs) {
                        const contactData = d.data();
                        const friendProfileRef = doc(db, 'artifacts', appId, 'users', contactData.friendId, 'secret_msn_profile', 'main');
                        const friendProfile = await getDoc(friendProfileRef);
                        let status = 'offline';
                        let avatar = '';
                        let statusText = '';
                        let username = contactData.name || 'Kontakt';
                        if (friendProfile.exists()) {
                            const fp = friendProfile.data() || {};
                            const lastSeen = fp.lastSeen?.toMillis() || 0;
                            if (Date.now() - lastSeen < 120000) status = 'online';
                            avatar = fp.avatar || '';
                            statusText = fp.statusText || '';
                            username = fp.username || username;
                            
                            // Derive shared secret for E2E encryption
                            if (myKeys && fp.publicKey) {
                                try {
                                    const friendPublicKey = await E2EE.importPublicKey(fp.publicKey);
                                    const sharedSecret = await E2EE.deriveSharedSecret(myKeys.privateKey, friendPublicKey);
                                    setSharedSecrets(prev => ({ ...prev, [contactData.friendId]: sharedSecret }));
                                } catch (e) {
                                    console.error("Error deriving shared secret:", e);
                                }
                            }
                        }
                        list.push({ id: d.id, ...contactData, name: username, status, avatar, statusText, isGroup: false });
                    }
                    setContacts(list);
                }, err => console.error("Contacts Err", err));
                return () => unsub();
            }, [user, myKeys]);
            
            // Load group conversations
            useEffect(() => {
                const q = query(
                    collection(db, 'artifacts', appId, 'secret_groups'),
                    where('members', 'array-contains', user.uid)
                );
                const unsub = onSnapshot(q, async (snap) => {
                    const list = [];
                    for (const d of snap.docs) {
                        const groupData = d.data();
                        list.push({ 
                            id: d.id, 
                            groupId: d.id,
                            name: groupData.name, 
                            avatar: groupData.avatar || '', 
                            members: groupData.members || [],
                            isGroup: true,
                            status: 'online'
                        });
                    }
                    setGroups(list);
                }, err => console.error("Groups Err", err));
                return () => unsub();
            }, [user]);

            useEffect(() => {
                const q = query(collection(db, 'artifacts', appId, 'secret_requests'), where('to', '==', user.uid), where('status', '==', 'pending'));
                const unsub = onSnapshot(q, (snap) => {
                    setRequests(snap.docs.map(d => ({ id: d.id, ...d.data() })));
                }, err => console.error("Requests Err", err));
                return () => unsub();
            }, [user]);

            useEffect(() => {
                if (!activeConversation) return;
                setMessageLimit(INITIAL_MESSAGE_LIMIT); // Reset limit when switching conversations
                
                const chatId = activeConversation.isGroup 
                    ? activeConversation.groupId 
                    : [user.uid, activeConversation.friendId].sort().join('_');
                    
                const collectionPath = activeConversation.isGroup
                    ? collection(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs')
                    : collection(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs');
                    
                const q = query(collectionPath, orderBy('ts', 'asc'), limit(messageLimit));
                const unsub = onSnapshot(q, async (snap) => {
                    const msgs = [];
                    const batch = writeBatch(db);
                    const now = Date.now();
                    let hasOperations = false;
                    
                    for (const msgDoc of snap.docs) {
                        const data = msgDoc.data();
                        
                        // Check if message is expired
                        const expiresAt = toMillis(data.expiresAt);
                        if (expiresAt > 0 && now > expiresAt) {
                            // Delete expired message
                            const msgRef = activeConversation.isGroup
                                ? doc(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs', msgDoc.id)
                                : doc(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs', msgDoc.id);
                            batch.delete(msgRef);
                            hasOperations = true;
                            continue;
                        }
                        
                        // Check if read-once message was already read
                        if (data.readOnce && data.readBy && data.readBy.includes(user.uid) && data.from !== user.uid) {
                            // Delete read-once message after it's been read
                            const msgRef = activeConversation.isGroup
                                ? doc(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs', msgDoc.id)
                                : doc(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs', msgDoc.id);
                            batch.delete(msgRef);
                            hasOperations = true;
                            continue;
                        }
                        
                        // Decrypt message
                        let decryptedText = data.text || '';
                        let decryptedImg = data.img || '';
                        
                        if (data.encrypted && !data.deleted) {
                            if (activeConversation.isGroup) {
                                // For group messages, decrypt using our own encrypted copy
                                if (data.encryptedText && data.encryptedText[user.uid]) {
                                    // We need to derive shared secret with the sender
                                    const senderSecret = sharedSecrets[data.from];
                                    if (senderSecret) {
                                        decryptedText = await E2EE.decrypt(data.encryptedText[user.uid], senderSecret);
                                    }
                                }
                                if (data.encryptedImg && data.encryptedImg[user.uid]) {
                                    const senderSecret = sharedSecrets[data.from];
                                    if (senderSecret) {
                                        decryptedImg = await E2EE.decrypt(data.encryptedImg[user.uid], senderSecret);
                                    }
                                }
                            } else {
                                // For 1-on-1 conversations
                                const secret = sharedSecrets[activeConversation.friendId];
                                if (secret) {
                                    if (data.encryptedText) {
                                        decryptedText = await E2EE.decrypt(data.encryptedText, secret);
                                    }
                                    if (data.encryptedImg) {
                                        decryptedImg = await E2EE.decrypt(data.encryptedImg, secret);
                                    }
                                }
                            }
                        }
                        
                        msgs.push({ 
                            id: msgDoc.id, 
                            ...data, 
                            text: decryptedText,
                            img: decryptedImg
                        });
                        
                        // Mark messages as read
                        if (data.from !== user.uid && (!data.readBy || !data.readBy.includes(user.uid))) {
                            const msgRef = activeConversation.isGroup
                                ? doc(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs', msgDoc.id)
                                : doc(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs', msgDoc.id);
                            const currentReadBy = data.readBy || [];
                            batch.update(msgRef, { readBy: [...currentReadBy, user.uid] });
                            hasOperations = true;
                        }
                    }
                    
                    if (hasOperations) {
                        await batch.commit();
                    }
                    
                    setMessages(msgs);
                    setTimeout(() => scrollRef.current?.scrollIntoView({ behavior: 'smooth' }), 100);
                });
                return () => unsub();
            }, [activeConversation, messageLimit, sharedSecrets]);

            const sendMsg = async (imgData = null) => {
                if ((!input.trim() && !imgData) || !activeConversation) return;
                
                const chatId = activeConversation.isGroup 
                    ? activeConversation.groupId 
                    : [user.uid, activeConversation.friendId].sort().join('_');
                
                if (editingMessage) {
                    // Edit existing message - encrypt if needed
                    const msgRef = activeConversation.isGroup
                        ? doc(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs', editingMessage.id)
                        : doc(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs', editingMessage.id);
                    
                    let updateData = { edited: serverTimestamp() };
                    
                    if (activeConversation.isGroup) {
                        // Encrypt for all group members
                        const encryptedForMembers = {};
                        for (const memberId of activeConversation.members) {
                            const secret = sharedSecrets[memberId];
                            if (secret && memberId !== user.uid) {
                                encryptedForMembers[memberId] = await E2EE.encrypt(input, secret);
                            }
                        }
                        updateData.encryptedText = encryptedForMembers;
                        updateData.encrypted = true;
                    } else {
                        const secret = sharedSecrets[activeConversation.friendId];
                        if (secret) {
                            updateData.encryptedText = await E2EE.encrypt(input, secret);
                            updateData.encrypted = true;
                        } else {
                            updateData.text = input;
                        }
                    }
                    
                    await updateDoc(msgRef, updateData);
                    setEditingMessage(null);
                } else {
                    // Send new message with encryption
                    const msgData = { 
                        from: user.uid, 
                        ts: serverTimestamp(),
                        readBy: [user.uid],
                        encrypted: true,
                        readOnce: readOnceMode
                    };
                    
                    // Calculate expiration time
                    if (messageExpiry !== 'never') {
                        const expiryMs = messageExpiry === '24h' ? 24 * 60 * 60 * 1000 : 7 * 24 * 60 * 60 * 1000;
                        msgData.expiresAt = new Date(Date.now() + expiryMs);
                    }
                    
                    if (activeConversation.isGroup) {
                        // Encrypt for all group members
                        if (input.trim()) {
                            const encryptedForMembers = {};
                            for (const memberId of activeConversation.members) {
                                const secret = sharedSecrets[memberId];
                                if (secret && memberId !== user.uid) {
                                    encryptedForMembers[memberId] = await E2EE.encrypt(input, secret);
                                }
                            }
                            msgData.encryptedText = encryptedForMembers;
                        }
                        
                        if (imgData) {
                            const encryptedImgForMembers = {};
                            for (const memberId of activeConversation.members) {
                                const secret = sharedSecrets[memberId];
                                if (secret && memberId !== user.uid) {
                                    encryptedImgForMembers[memberId] = await E2EE.encrypt(imgData, secret);
                                }
                            }
                            msgData.encryptedImg = encryptedImgForMembers;
                        }
                    } else {
                        // Encrypt for single recipient
                        const secret = sharedSecrets[activeConversation.friendId];
                        if (secret) {
                            if (input.trim()) {
                                msgData.encryptedText = await E2EE.encrypt(input, secret);
                            }
                            if (imgData) {
                                msgData.encryptedImg = await E2EE.encrypt(imgData, secret);
                            }
                        } else {
                            // Fallback if encryption not available
                            msgData.text = input;
                            msgData.img = imgData;
                            msgData.encrypted = false;
                        }
                    }
                    
                    // Add reply reference if replying
                    if (replyingTo) {
                        msgData.replyTo = {
                            messageId: replyingTo.id,
                            text: replyingTo.text || '[Image]',
                            from: replyingTo.from
                        };
                        setReplyingTo(null);
                    }
                    
                    const collectionPath = activeConversation.isGroup
                        ? collection(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs')
                        : collection(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs');
                    
                    await addDoc(collectionPath, msgData);
                }
                
                setInput('');
                // Keep keyboard open by re-focusing the input
                setTimeout(() => inputRef.current?.focus(), INPUT_REFOCUS_DELAY);
            };

            const deleteMsg = async (msgId) => {
                if (!activeConversation) return;
                const chatId = activeConversation.isGroup 
                    ? activeConversation.groupId 
                    : [user.uid, activeConversation.friendId].sort().join('_');
                const msgRef = activeConversation.isGroup
                    ? doc(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs', msgId)
                    : doc(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs', msgId);
                await updateDoc(msgRef, { 
                    deleted: true, 
                    text: '', 
                    encryptedText: deleteField(),
                    encryptedImg: deleteField(),
                    img: ''
                });
            };

            const createGroup = async () => {
                if (!groupName.trim() || selectedGroupMembers.length < 2) {
                    alert("Bitte gib einen Gruppennamen ein und w√§hle mindestens 2 Mitglieder aus.");
                    return;
                }
                
                const groupMembers = [user.uid, ...selectedGroupMembers];
                const groupData = {
                    name: groupName,
                    avatar: '',
                    members: groupMembers,
                    createdBy: user.uid,
                    createdAt: serverTimestamp()
                };
                
                await addDoc(collection(db, 'artifacts', appId, 'secret_groups'), groupData);
                alert("Gruppe erstellt!");
                setGroupName('');
                setSelectedGroupMembers([]);
                setView('list');
            };

            const startEditMsg = (msg) => {
                setEditingMessage(msg);
                setInput(msg.text);
                setReplyingTo(null);
                inputRef.current?.focus();
            };

            const startReplyMsg = (msg) => {
                setReplyingTo(msg);
                setEditingMessage(null);
                inputRef.current?.focus();
            };

            const cancelEdit = () => {
                setEditingMessage(null);
                setInput('');
            };

            const cancelReply = () => {
                setReplyingTo(null);
            };

            const handlePhoto = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const base64 = await compressImage(file);
                    sendMsg(base64);
                }
            };

            const openCamera = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'user' } 
                    });
                    setCameraStream(stream);
                    setCameraOpen(true);
                    // Wait for video element to be rendered and set stream
                    setTimeout(() => {
                        if (videoRef.current) {
                            videoRef.current.srcObject = stream;
                            videoRef.current.play().catch(err => {
                                console.error('Video play error:', err);
                            });
                        }
                    }, 100);
                } catch (err) {
                    console.error('Camera access error:', err);
                    alert('Fehler beim Zugriff auf die Kamera. Bitte stelle sicher, dass du die Kameraberechtigung erteilt hast.');
                }
            };

            const closeCamera = () => {
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                    setCameraStream(null);
                }
                setCameraOpen(false);
            };

            const capturePhoto = async () => {
                if (!videoRef.current || !canvasRef.current) {
                    alert('Kamera nicht bereit. Bitte versuche es erneut.');
                    return;
                }
                
                const video = videoRef.current;
                const canvas = canvasRef.current;
                
                // Check if video is ready
                if (video.readyState !== video.HAVE_ENOUGH_DATA) {
                    alert('Video wird geladen. Bitte warte einen Moment.');
                    return;
                }
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);
                
                canvas.toBlob(async (blob) => {
                    if (!blob) {
                        alert('Fehler beim Erstellen des Fotos. Bitte versuche es erneut.');
                        return;
                    }
                    
                    try {
                        const file = new File([blob], 'camera-photo.jpg', { type: 'image/jpeg' });
                        const base64 = await compressImage(file);
                        await sendMsg(base64);
                        closeCamera();
                    } catch (err) {
                        console.error('Photo processing error:', err);
                        alert('Fehler beim Verarbeiten des Fotos.');
                    }
                }, 'image/jpeg', 0.8);
            };


            const sendRequest = async () => {
                if(!addCode) return;
                const q = query(collection(db, 'artifacts', appId, 'secret_public_codes'), where('__name__', '==', addCode.trim()));
                const snap = await getDocs(q);
                if (!snap.empty) {
                    const targetId = snap.docs[0].data().userId;
                    if(targetId === user.uid) return alert("Das bist du!");
                    await addDoc(collection(db, 'artifacts', appId, 'secret_requests'), { from: user.uid, fromName: user.email || "Gast", to: targetId, status: 'pending', ts: serverTimestamp() });
                    alert("Anfrage gesendet!"); setAddCode(''); setView('list');
                } else alert("Code nicht gefunden");
            };

            const acceptRequest = async (req) => {
                await setDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'secret_contacts', req.from), { friendId: req.from, name: req.fromName });
                await setDoc(doc(db, 'artifacts', appId, 'users', req.from, 'secret_contacts', user.uid), { friendId: user.uid, name: user.email || "Gast" });
                await deleteDoc(doc(db, 'artifacts', appId, 'secret_requests', req.id));
            };

            const saveMyProfile = async () => {
                setSavingProfile(true);
                try {
                    const profileRef = doc(db, 'artifacts', appId, 'users', user.uid, 'secret_msn_profile', 'main');
                    await setDoc(profileRef, {
                        username: profile.username || (user.email?.split('@')[0] || "Gast"),
                        avatar: profile.avatar || '',
                        statusText: profile.statusText || '',
                        bio: profile.bio || '',
                        lastSeen: serverTimestamp(),
                        status: 'online'
                    }, { merge: true });
                    setView('list');
                } catch (e) {
                    console.error(e);
                    alert("Profil konnte nicht gespeichert werden.");
                } finally {
                    setSavingProfile(false);
                }
            };

            const handleAvatarUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                try {
                    const base64 = await compressImage(file);
                    setProfile(p => ({ ...p, avatar: base64 }));
                } catch (err) {
                    console.error(err);
                    alert("Bild konnte nicht verarbeitet werden.");
                }
            };

            const onlineContacts = contacts.filter(c => c.status === 'online');
            const offlineContacts = contacts.filter(c => c.status !== 'online');

            const sortContacts = (contactList) => {
                const sorted = [...contactList];
                if (friendSortMode === 'alpha') {
                    sorted.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
                } else if (friendSortMode === 'lastActive') {
                    sorted.sort((a, b) => {
                        const aTime = a.lastSeen?.toMillis?.() || 0;
                        const bTime = b.lastSeen?.toMillis?.() || 0;
                        return bTime - aTime;
                    });
                }
                // 'status' mode keeps default online/offline split
                return sorted;
            };

            const sortedOnline = sortContacts(onlineContacts);
            const sortedOffline = sortContacts(offlineContacts);

            const handleSortChange = (mode) => {
                setFriendSortMode(mode);
                localStorage.setItem('msn_friend_sort', mode);
            };

            const viewFriendProfile = async (contact) => {
                const friendProfileRef = doc(db, 'artifacts', appId, 'users', contact.friendId, 'secret_msn_profile', 'main');
                const friendProfile = await getDoc(friendProfileRef);
                if (friendProfile.exists()) {
                    const fp = friendProfile.data() || {};
                    setViewingFriendProfile({
                        ...contact,
                        bio: fp.bio || '',
                        username: fp.username || contact.name,
                        avatar: fp.avatar || '',
                        statusText: fp.statusText || ''
                    });
                    setView('friendProfile');
                } else {
                    alert("Profil konnte nicht geladen werden.");
                }
            };

            return (
                <div className={`fixed inset-0 z-[100] ${messagesDarkMode ? 'bg-black' : 'bg-black/80'} flex items-center justify-center font-msn ${messagesDarkMode ? 'text-white' : 'text-black'}`}>
                    {avatarZoom && (
                        <div className="fixed inset-0 z-[110] bg-black/80 flex items-center justify-center p-4" onClick={() => setAvatarZoom(null)}>
                            <div className={`max-w-sm w-full ${messagesDarkMode ? 'bg-black border-slate-800' : 'bg-white border-gray-300'} rounded-lg overflow-hidden border shadow-xl`} onClick={(e)=>e.stopPropagation()}>
                                <div className={`${messagesDarkMode ? 'bg-slate-900 text-white' : 'msn-header'} p-2 flex justify-between items-center`}>
                                    <div className="text-xs font-bold">{avatarZoom.name || 'Profilbild'}</div>
                                    <button onClick={() => setAvatarZoom(null)} className="hover:bg-red-500/50 rounded px-2"><X size={16}/></button>
                                </div>
                                <div className={`p-4 ${messagesDarkMode ? 'bg-black' : 'bg-white'} flex items-center justify-center`}>
                                    <img src={avatarZoom.src} className={`max-h-[60vh] w-auto rounded ${messagesDarkMode ? 'border-slate-700' : 'border-gray-200'} border`} />
                                </div>
                            </div>
                        </div>
                    )}

                    {cameraOpen && (
                        <div className="fixed inset-0 z-[110] bg-black flex items-center justify-center" onClick={closeCamera}>
                            <div className="w-full h-full flex flex-col" onClick={(e)=>e.stopPropagation()}>
                                <div className="bg-slate-900 text-white p-2 flex justify-between items-center">
                                    <div className="text-sm font-bold">Foto aufnehmen</div>
                                    <button onClick={closeCamera} className="hover:bg-red-500/50 rounded px-2"><X size={20}/></button>
                                </div>
                                <div className="flex-1 flex items-center justify-center bg-black">
                                    <video ref={videoRef} autoPlay playsInline className="max-w-full max-h-full"></video>
                                    <canvas ref={canvasRef} className="hidden"></canvas>
                                </div>
                                <div className="bg-slate-900 p-4 flex justify-center">
                                    <button onClick={capturePhoto} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-full">
                                        üì∑ Foto aufnehmen
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className={`w-full h-screen ${messagesDarkMode ? 'bg-black border border-slate-800' : 'msn-window'} rounded-t-lg flex flex-col overflow-hidden relative`}>
                        <div className={`${messagesDarkMode ? 'bg-black border-b border-slate-800 text-white' : 'msn-header'} p-2 flex justify-between items-center cursor-move`}>
                            <div className="flex items-center gap-2"><MessageCircle size={16}/><span className="font-bold text-sm">MSN Messenger</span></div>
                            <div className="flex items-center gap-1">
                                <button onClick={() => setView('profile')} title="Profil" className="hover:bg-white/10 rounded px-2"><User size={16}/></button>
                                <button onClick={onClose} className="hover:bg-red-500/50 rounded px-2"><X size={16}/></button>
                            </div>
                        </div>

                        <div className={`${messagesDarkMode ? 'bg-black border-b border-slate-800 text-white' : 'msn-toolbar'} p-2 flex gap-4 text-xs`}>
                            <button onClick={() => setView('list')} className={`hover:underline ${messagesDarkMode ? 'text-blue-400' : 'text-blue-800'}`}>Kontakte</button>
                            <button onClick={() => setView('add')} className={`hover:underline ${messagesDarkMode ? 'text-blue-400' : 'text-blue-800'}`}>Hinzuf√ºgen</button>
                            <button onClick={() => setView('profile')} className={`hover:underline ${messagesDarkMode ? 'text-blue-400' : 'text-blue-800'}`}>Profil</button>
                            <span className={`flex-1 text-right ${messagesDarkMode ? 'text-gray-400' : 'text-gray-500'} select-all`}>{myCode}</span>
                        </div>

                        <div className={`flex-1 ${messagesDarkMode ? 'bg-black text-white' : 'msn-surface'} p-3 overflow-y-auto relative`}>
                            {view === 'profile' && (
                                <div className="p-2 space-y-3">
                                    <h3 className="font-bold mb-1">Mein Profil</h3>
                                    <div className="flex items-center gap-3">
                                        <button
                                            onClick={() => setAvatarZoom({ src: avatarSrc(user.uid, profile.avatar), name: profile.username || 'Ich' })}
                                            className={`w-14 h-14 border ${messagesDarkMode ? 'border-slate-700 bg-black' : 'border-gray-400 bg-white'} p-0.5 rounded overflow-hidden`}
                                            title="Klicken zum Vergr√∂ssern"
                                        >
                                            <img src={avatarSrc(user.uid, profile.avatar)} className="w-full h-full object-cover"/>
                                        </button>
                                        <div className="flex-1">
                                            <div className={`text-xs ${messagesDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>Anzeige-Name</div>
                                            <input value={profile.username} onChange={e => setProfile(p => ({ ...p, username: e.target.value }))} className={`border p-2 w-full text-sm ${messagesDarkMode ? 'bg-black border-slate-700 text-white' : 'bg-white border-gray-300 text-black'}`} placeholder="Name"/>
                                        </div>
                                    </div>

                                    <div>
                                        <div className={`text-xs ${messagesDarkMode ? 'text-gray-400' : 'text-gray-500'} mb-1`}>Status (Text)</div>
                                        <input value={profile.statusText} onChange={e => setProfile(p => ({ ...p, statusText: e.target.value }))} className={`border p-2 w-full text-sm ${messagesDarkMode ? 'bg-black border-slate-700 text-white' : 'bg-white border-gray-300 text-black'}`} placeholder="z. B. Besch√§ftigt, Pause, unterwegs..."/>
                                    </div>

                                    <div>
                                        <div className={`text-xs ${messagesDarkMode ? 'text-gray-400' : 'text-gray-500'} mb-1`}>Bio</div>
                                        <textarea value={profile.bio} onChange={e => setProfile(p => ({ ...p, bio: e.target.value }))} className={`border p-2 w-full text-sm ${messagesDarkMode ? 'bg-black border-slate-700 text-white' : 'bg-white border-gray-300 text-black'}`} placeholder="Erz√§hl etwas √ºber dich..." rows="3"/>
                                    </div>

                                    <div className="flex items-center gap-2">
                                        <label className={`cursor-pointer px-3 py-1 text-sm ${messagesDarkMode ? 'bg-slate-900 border-slate-700 active:bg-slate-800' : 'bg-[#f0f0f0] border-gray-400 active:bg-gray-300'} border`}>
                                            Profilbild √§ndern
                                            <input type="file" accept="image/*" className="hidden" onChange={handleAvatarUpload}/>
                                        </label>
                                        <button onClick={() => setProfile(p => ({ ...p, avatar: '' }))} className={`text-sm underline ${messagesDarkMode ? 'text-blue-400' : 'text-blue-600'}`}>Standard</button>
                                    </div>

                                    <div className={`border-t pt-3 mt-1 ${messagesDarkMode ? 'border-slate-800' : 'border-gray-300'}`}>
                                        <div className={`text-xs mb-2 ${messagesDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>Design-Einstellungen</div>
                                        <label className={`flex items-center gap-2 cursor-pointer p-2 rounded border ${messagesDarkMode ? 'bg-slate-900 border-slate-700' : 'bg-[#f9f9f9] border-gray-300'}`}>
                                            <input 
                                                type="checkbox" 
                                                checked={messagesDarkMode} 
                                                onChange={(e) => setMessagesDarkMode(e.target.checked)}
                                                className="w-4 h-4"
                                            />
                                            <span className="text-sm flex-1">AMOLED Dunkelmodus aktivieren</span>
                                        </label>
                                        <div className={`text-[10px] mt-1 ml-6 ${messagesDarkMode ? 'text-gray-500' : 'text-gray-400'}`}>Tiefes Schwarz f√ºr OLED-Displays</div>
                                    </div>

                                    <div className="flex gap-2 pt-2">
                                        <button onClick={() => setView('list')} className={`text-sm underline ${messagesDarkMode ? 'text-blue-400' : 'text-blue-600'}`}>Zur√ºck</button>
                                        <button onClick={saveMyProfile} disabled={savingProfile} className={`ml-auto px-3 py-1 text-sm border disabled:opacity-50 ${messagesDarkMode ? 'bg-slate-900 border-slate-700 active:bg-slate-800' : 'bg-[#f0f0f0] border-gray-400 active:bg-gray-300'}`}>
                                            {savingProfile ? 'Speichern...' : 'Speichern'}
                                        </button>
                                    </div>
                                </div>
                            )}

                            {view === 'list' && (
                                <>
                                    <div className="flex items-center gap-3 mb-3 p-3 border border-slate-200/80 rounded-xl bg-white/70 shadow-sm">
                                        <button
                                            onClick={() => setAvatarZoom({ src: avatarSrc(user.uid, profile.avatar), name: profile.username || (user.email?.split('@')[0] || 'Gast') })}
                                            className="w-10 h-10 border border-gray-400 bg-white p-0.5 rounded overflow-hidden"
                                            title="Klicken zum Vergr√∂ssern"
                                        >
                                            <img src={avatarSrc(user.uid, profile.avatar)} className="w-full h-full object-cover"/>
                                        </button>
                                        <div className="min-w-0">
                                            <div className="text-sm font-bold text-black truncate">{profile.username || (user.email?.split('@')[0] || "Gast")}</div>
                                            <div className="text-xs text-green-600 flex items-center gap-1">
                                                <div className="w-2 h-2 rounded-full bg-green-500"></div> (Online)
                                            </div>
                                            {profile.statusText && <div className="text-[11px] text-gray-600 truncate">"{profile.statusText}"</div>}
                                        </div>
                                    </div>

                                    {requests.length > 0 && (
                                        <div className="mb-2 bg-yellow-100 border border-yellow-300 p-2 rounded text-black text-xs">
                                            <div className="font-bold mb-1 flex items-center gap-1"><AlertCircle size={12}/> {requests.length} Anfragen</div>
                                            {requests.map(r => (
                                                <div key={r.id} className="flex justify-between items-center mt-1">
                                                    <span className="truncate">{r.fromName}</span>
                                                    <button onClick={() => acceptRequest(r)} className="text-blue-600 underline">Annehmen</button>
                                                </div>
                                            ))}
                                        </div>
                                    )}

                                    <div className="mb-2 flex gap-2 text-[10px] border-b border-slate-200 pb-3">
                                        <button onClick={() => handleSortChange('status')} className={`px-2 py-1 rounded-full text-[10px] font-semibold ${friendSortMode === 'status' ? 'bg-slate-900 text-white' : 'bg-slate-100 text-slate-600'}`}>Status</button>
                                        <button onClick={() => handleSortChange('alpha')} className={`px-2 py-1 rounded-full text-[10px] font-semibold ${friendSortMode === 'alpha' ? 'bg-slate-900 text-white' : 'bg-slate-100 text-slate-600'}`}>A-Z</button>
                                        <button onClick={() => handleSortChange('lastActive')} className={`px-2 py-1 rounded-full text-[10px] font-semibold ${friendSortMode === 'lastActive' ? 'bg-slate-900 text-white' : 'bg-slate-100 text-slate-600'}`}>Zuletzt aktiv</button>
                                    </div>

                                    <div className="text-[11px] font-bold text-slate-400 uppercase mb-2">Online ({sortedOnline.length})</div>
                                    <div className="space-y-1">
                                        {sortedOnline.map(c => (
                                            <div key={c.id} className="flex items-center gap-3 p-2 hover:bg-slate-100/70 text-slate-900 text-sm rounded-xl transition">
                                                <button
                                                    onClick={(e) => { e.stopPropagation(); setAvatarZoom({ src: avatarSrc(c.friendId, c.avatar), name: c.name }); }}
                                                    className="w-7 h-7 border border-gray-300 bg-white rounded overflow-hidden"
                                                    title="Profilbild vergr√∂ssern"
                                                >
                                                    <img src={avatarSrc(c.friendId, c.avatar)} className="w-full h-full object-cover" />
                                                </button>
                                                <div className="w-3 h-3 rounded-full msn-status-online border border-green-700"></div>
                                                <div className="min-w-0 flex-1 cursor-pointer" onClick={() => { setActiveConversation(c); setView('message'); }}>
                                                    <div className="truncate">{c.name}</div>
                                                    {c.statusText && <div className="text-[10px] text-gray-500 truncate">"{c.statusText}"</div>}
                                                </div>
                                                <button onClick={(e) => { e.stopPropagation(); viewFriendProfile(c); }} className="p-1 hover:bg-blue-100 rounded" title="Profil anzeigen">
                                                    <User size={14} className="text-blue-600" />
                                                </button>
                                            </div>
                                        ))}
                                    </div>

                                    <div className="text-[11px] font-bold text-slate-400 uppercase mb-2 mt-4">Offline ({sortedOffline.length})</div>
                                    <div className="space-y-1">
                                        {sortedOffline.map(c => (
                                            <div key={c.id} className="flex items-center gap-3 p-2 hover:bg-slate-100/70 text-slate-500 text-sm rounded-xl transition">
                                                <button
                                                    onClick={(e) => { e.stopPropagation(); setAvatarZoom({ src: avatarSrc(c.friendId, c.avatar), name: c.name }); }}
                                                    className="w-7 h-7 border border-gray-300 bg-white rounded overflow-hidden"
                                                    title="Profilbild vergr√∂ssern"
                                                >
                                                    <img src={avatarSrc(c.friendId, c.avatar)} className="w-full h-full object-cover" />
                                                </button>
                                                <div className="w-3 h-3 rounded-full msn-status-offline border border-red-800"></div>
                                                <div className="min-w-0 flex-1 cursor-pointer" onClick={() => { setActiveConversation(c); setView('message'); }}>
                                                    <div className="truncate">{c.name}</div>
                                                    {c.statusText && <div className="text-[10px] text-gray-400 truncate">"{c.statusText}"</div>}
                                                </div>
                                                <button onClick={(e) => { e.stopPropagation(); viewFriendProfile(c); }} className="p-1 hover:bg-blue-100 rounded" title="Profil anzeigen">
                                                    <User size={14} className="text-gray-400" />
                                                </button>
                                            </div>
                                        ))}
                                    </div>
                                    
                                    {/* Groups section */}
                                    <div className="text-[11px] font-bold text-slate-400 uppercase mb-2 mt-4 flex items-center gap-2">
                                        Gruppen ({groups.length})
                                        <button onClick={() => setView('createGroup')} className="ml-auto text-blue-600 hover:underline text-xs normal-case" title="Gruppe erstellen">
                                            <Users size={14} className="inline"/> Neu
                                        </button>
                                    </div>
                                    <div className="space-y-1">
                                        {groups.map(g => (
                                            <div key={g.id} className="flex items-center gap-3 p-2 hover:bg-slate-100/70 text-slate-900 text-sm rounded-xl cursor-pointer transition" onClick={() => { setActiveConversation(g); setView('message'); }}>
                                                <div className="w-7 h-7 border border-gray-300 bg-gradient-to-br from-blue-400 to-purple-500 rounded flex items-center justify-center text-white text-xs font-bold">
                                                    {g.name.substring(0, 2).toUpperCase()}
                                                </div>
                                                <div className="min-w-0 flex-1">
                                                    <div className="truncate font-semibold">{g.name}</div>
                                                    <div className="text-[10px] text-gray-500">{g.members.length} Mitglieder</div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </>
                            )}
                            
                            {view === 'createGroup' && (
                                    <div className="text-slate-900 p-2">
                                    <h3 className="font-bold mb-2 flex items-center gap-2">
                                        <Users size={16}/>
                                        Gruppe erstellen
                                    </h3>
                                    <div className="mb-3">
                                        <label className="text-xs text-gray-600 block mb-1">Gruppenname</label>
                                        <input 
                                            value={groupName} 
                                            onChange={e => setGroupName(e.target.value)} 
                                            placeholder="Meine Gruppe..." 
                                            className="border border-slate-200 p-2 w-full text-sm rounded-lg"
                                        />
                                    </div>
                                    <div className="mb-3">
                                        <label className="text-xs text-gray-600 block mb-1">Mitglieder ausw√§hlen (mind. 2)</label>
                                        <div className="border border-slate-200 rounded-lg p-2 max-h-48 overflow-y-auto space-y-1 bg-white/70">
                                            {contacts.map(c => (
                                                <label key={c.id} className="flex items-center gap-2 p-2 hover:bg-slate-100/70 rounded-lg cursor-pointer">
                                                    <input 
                                                        type="checkbox"
                                                        checked={selectedGroupMembers.includes(c.friendId)}
                                                        onChange={(e) => {
                                                            if (e.target.checked) {
                                                                setSelectedGroupMembers(prev => [...prev, c.friendId]);
                                                            } else {
                                                                setSelectedGroupMembers(prev => prev.filter(id => id !== c.friendId));
                                                            }
                                                        }}
                                                    />
                                                    <img src={avatarSrc(c.friendId, c.avatar)} className="w-6 h-6 rounded border"/>
                                                    <span className="text-sm">{c.name}</span>
                                                </label>
                                            ))}
                                        </div>
                                    </div>
                                    <div className="flex gap-2">
                                        <button onClick={() => setView('list')} className="text-sm underline text-blue-600">Zur√ºck</button>
                                        <button 
                                            onClick={createGroup} 
                                            disabled={!groupName.trim() || selectedGroupMembers.length < 2}
                                            className="ml-auto bg-slate-900 text-white border border-slate-900 px-3 py-1 text-sm rounded-lg active:bg-slate-800 disabled:opacity-50 disabled:cursor-not-allowed"
                                        >
                                            Erstellen
                                        </button>
                                    </div>
                                </div>
                            )}

                            {view === 'add' && (
                                <div className="text-slate-900 p-2">
                                    <h3 className="font-bold mb-2">Freund hinzuf√ºgen</h3>
                                    <input value={addCode} onChange={e => setAddCode(e.target.value)} placeholder="rai123456..." className="border border-slate-200 p-2 w-full mb-2 text-sm rounded-lg"/>
                                    <button onClick={sendRequest} className="bg-slate-900 text-white border border-slate-900 px-3 py-1 text-sm rounded-lg active:bg-slate-800">Senden</button>
                                    <button onClick={() => setView('list')} className="ml-2 text-sm underline text-blue-600">Zur√ºck</button>
                                </div>
                            )}

                            {view === 'friendProfile' && viewingFriendProfile && (
                                    <div className="text-slate-900 p-2 space-y-3">
                                    <div className="flex items-center justify-between mb-2">
                                        <h3 className="font-bold">Freund-Profil</h3>
                                        <button onClick={() => setView('list')} className="text-sm underline text-blue-600">Zur√ºck</button>
                                    </div>
                                    <div className="flex items-center gap-3 p-3 border border-gray-300 rounded bg-gradient-to-b from-white to-[#f0f0f0]">
                                        <button
                                            onClick={() => setAvatarZoom({ src: avatarSrc(viewingFriendProfile.friendId, viewingFriendProfile.avatar), name: viewingFriendProfile.username })}
                                            className="w-16 h-16 border border-gray-400 bg-white p-0.5 rounded overflow-hidden"
                                            title="Klicken zum Vergr√∂ssern"
                                        >
                                            <img src={avatarSrc(viewingFriendProfile.friendId, viewingFriendProfile.avatar)} className="w-full h-full object-cover"/>
                                        </button>
                                        <div className="flex-1">
                                            <div className="font-bold text-lg">{viewingFriendProfile.username}</div>
                                            <div className="text-xs flex items-center gap-1 mt-1">
                                                <div className={`w-2 h-2 rounded-full ${viewingFriendProfile.status === 'online' ? 'bg-green-500' : 'bg-gray-400'}`}></div>
                                                <span className={viewingFriendProfile.status === 'online' ? 'text-green-600' : 'text-gray-500'}>
                                                    {viewingFriendProfile.status === 'online' ? 'Online' : 'Offline'}
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                    {viewingFriendProfile.statusText && (
                                        <div className="p-2 bg-blue-50 border border-blue-200 rounded">
                                            <div className="text-[10px] text-gray-500 uppercase font-bold mb-1">Status</div>
                                            <div className="text-sm">"{viewingFriendProfile.statusText}"</div>
                                        </div>
                                    )}
                                    {viewingFriendProfile.bio && (
                                        <div className="p-2 bg-purple-50 border border-purple-200 rounded">
                                            <div className="text-[10px] text-gray-500 uppercase font-bold mb-1">Bio</div>
                                            <div className="text-sm whitespace-pre-wrap">{viewingFriendProfile.bio}</div>
                                        </div>
                                    )}
                                    <button 
                                        onClick={() => { setActiveConversation(viewingFriendProfile); setView('message'); }} 
                                        className="w-full bg-blue-500 text-white p-3 rounded font-bold hover:bg-blue-600 flex items-center justify-center gap-2"
                                    >
                                        <MessageCircle size={16} /> Nachricht senden
                                    </button>
                                </div>
                            )}

                            {view === 'message' && activeConversation && (
                                <div className="flex flex-col h-full">
                                    <div className="flex items-center gap-2 border-b border-slate-200 pb-3 mb-3">
                                        <button onClick={() => setView('list')} className="text-slate-700 hover:text-slate-900"><ArrowLeft size={16} /></button>
                                        <button
                                            onClick={() => activeConversation.isGroup 
                                                ? null 
                                                : setAvatarZoom({ src: avatarSrc(activeConversation.friendId, activeConversation.avatar), name: activeConversation.name })}
                                            className={`w-8 h-8 border border-slate-200 rounded-full overflow-hidden ${activeConversation.isGroup ? 'bg-gradient-to-br from-blue-500 to-purple-500 flex items-center justify-center text-white text-xs font-bold' : 'bg-white'}`}
                                            title={activeConversation.isGroup ? "Gruppe" : "Profilbild vergr√∂ssern"}
                                        >
                                            {activeConversation.isGroup 
                                                ? activeConversation.name.substring(0, 2).toUpperCase()
                                                : <img src={avatarSrc(activeConversation.friendId, activeConversation.avatar)} className="w-full h-full object-cover"/>
                                            }
                                        </button>
                                        <div className="flex-1">
                                            <div className="text-slate-900 font-semibold text-sm truncate flex items-center gap-1">
                                                {activeConversation.name}
                                                {!activeConversation.isGroup && sharedSecrets[activeConversation.friendId] && (
                                                    <Shield size={12} className="text-green-600" title="Ende-zu-Ende verschl√ºsselt"/>
                                                )}
                                            </div>
                                            {activeConversation.isGroup && (
                                                <div className="text-[10px] text-gray-500">{activeConversation.members.length} Mitglieder</div>
                                            )}
                                        </div>
                                        {!activeConversation.isGroup && (
                                            <span className="text-[11px] text-slate-500">{activeConversation.status === 'online' ? 'Online' : 'Offline'}</span>
                                        )}
                                    </div>
                                    {activeConversation.statusText && !activeConversation.isGroup && <div className="text-[11px] text-slate-500 mb-3 truncate">Status: "{activeConversation.statusText}"</div>}
                                    
                                    {/* Message Settings */}
                                    <div className="bg-emerald-50/80 border border-emerald-200/80 p-2 mb-3 rounded-xl">
                                        <div className="flex items-center gap-2 mb-1">
                                            <Shield size={12} className={messagesDarkMode ? 'text-green-400' : 'text-green-600'}/>
                                            <span className={`text-[10px] font-bold ${messagesDarkMode ? 'text-green-300' : 'text-green-700'}`}>Sicherheitseinstellungen</span>
                                        </div>
                                        <div className="flex flex-wrap gap-2 text-[10px]">
                                            <label className="flex items-center gap-1 cursor-pointer">
                                                <input 
                                                    type="checkbox"
                                                    checked={readOnceMode}
                                                    onChange={(e) => setReadOnceMode(e.target.checked)}
                                                />
                                                <span>Nach Lesen l√∂schen</span>
                                            </label>
                                            <select 
                                                value={messageExpiry} 
                                                onChange={(e) => setMessageExpiry(e.target.value)}
                                                className={`border rounded px-1 text-[10px] ${messagesDarkMode ? 'bg-black border-slate-700 text-slate-200' : 'border-gray-300'}`}
                                            >
                                                <option value="24h">24h Ablauf</option>
                                                <option value="7d">7 Tage Ablauf</option>
                                                <option value="never">Kein Ablauf</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div className="flex-1 overflow-y-auto space-y-3 p-3 bg-white/80 rounded-xl border border-slate-200">
                                        {hasMoreMessages && (
                                            <button 
                                                onClick={() => setMessageLimit(prev => prev + MESSAGE_BATCH_SIZE)} 
                                                className="w-full py-2 mb-2 bg-blue-500/10 text-blue-600 rounded text-xs font-bold hover:bg-blue-500/20"
                                            >
                                                {t('loadMoreMessages')}
                                            </button>
                                        )}
                                        {messages.map((m) => {
                                            const isOwn = m.from === user.uid;
                                            const isRead = m.readBy && activeConversation.isGroup 
                                                ? m.readBy.length > 1 // For groups, show if read by others
                                                : m.readBy.includes(activeConversation.friendId);
                                            const isDeleted = m.deleted;
                                            const isEncrypted = m.encrypted;
                                            
                                            return (
                                                <div key={m.id} className={`text-sm ${isOwn ? 'text-slate-900' : 'text-slate-700'} relative group`}>
                                                    <div className={`flex items-start gap-3 ${isOwn ? 'justify-end' : 'justify-start'}`}>
                                                        <div className="flex-1">
                                                            <div className="flex items-center gap-2 mb-1 text-[11px] text-slate-500">
                                                                <span className="font-semibold text-slate-600">{isOwn ? 'Ich' : (activeConversation.isGroup ? '...' : activeConversation.name)}</span>
                                                                {isEncrypted && <Shield size={10} className="text-emerald-500" title="Verschl√ºsselt"/>}
                                                                {m.readOnce && <Eye size={10} className="text-amber-500" title="Einmalig lesbar"/>}
                                                                {m.expiresAt && (
                                                                    <Clock size={10} className="text-blue-500" title={`L√§uft ab: ${new Date(toMillis(m.expiresAt)).toLocaleString('de-DE')}`}/>
                                                                )}
                                                            </div>
                                                            <div className={`max-w-[75%] rounded-2xl px-4 py-2 shadow-sm ${isOwn ? 'ml-auto bg-gradient-to-br from-blue-500 to-indigo-500 text-white' : 'bg-white border border-slate-200 text-slate-900'}`}>
                                                                {m.replyTo && (
                                                                    <div className={`text-[10px] ${isOwn ? 'text-blue-100' : 'text-slate-500'} border-l-2 ${isOwn ? 'border-blue-200' : 'border-slate-300'} pl-2 mb-1 italic`}>
                                                                        Antwort auf: {m.replyTo.text}
                                                                    </div>
                                                                )}
                                                                {isDeleted ? (
                                                                    <span className="text-xs opacity-60 italic">[Nachricht gel√∂scht]</span>
                                                                ) : m.img ? (
                                                                    <img src={m.img} className={`max-w-[200px] rounded-xl border ${isOwn ? 'border-blue-300/40' : 'border-slate-200'} block`} />
                                                                ) : (
                                                                    <span className="text-sm leading-relaxed">{m.text}</span>
                                                                )}
                                                                {m.edited && !isDeleted && (
                                                                    <span className={`text-[9px] ${isOwn ? 'text-blue-100' : 'text-slate-400'} ml-2`}>(bearbeitet)</span>
                                                                )}
                                                                {isOwn && !isDeleted && (
                                                                    <span className="text-[10px] text-blue-100 ml-2">
                                                                        {isRead ? '‚úì‚úì' : '‚úì'}
                                                                    </span>
                                                                )}
                                                            </div>
                                                        </div>
                                                        {isOwn && !isDeleted && (
                                                            <div className="opacity-0 group-hover:opacity-100 flex gap-1">
                                                                <button onClick={() => startReplyMsg(m)} className={`p-0.5 ${messagesDarkMode ? 'text-gray-400 hover:text-blue-300' : 'text-gray-500 hover:text-blue-600'}`} title="Antworten">
                                                                    <ArrowLeft size={12} className="rotate-180" />
                                                                </button>
                                                                {!m.img && (
                                                                    <button onClick={() => startEditMsg(m)} className={`p-0.5 ${messagesDarkMode ? 'text-gray-400 hover:text-green-300' : 'text-gray-500 hover:text-green-600'}`} title="Bearbeiten">
                                                                        <Edit3 size={12} />
                                                                    </button>
                                                                )}
                                                                <button onClick={() => deleteMsg(m.id)} className={`p-0.5 ${messagesDarkMode ? 'text-gray-400 hover:text-red-300' : 'text-gray-500 hover:text-red-600'}`} title="L√∂schen">
                                                                    <Trash2 size={12} />
                                                                </button>
                                                            </div>
                                                        )}
                                                        {!isOwn && !isDeleted && (
                                                            <div className="opacity-0 group-hover:opacity-100">
                                                                <button onClick={() => startReplyMsg(m)} className={`p-0.5 ${messagesDarkMode ? 'text-gray-400 hover:text-blue-300' : 'text-gray-500 hover:text-blue-600'}`} title="Antworten">
                                                                    <ArrowLeft size={12} className="rotate-180" />
                                                                </button>
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                        <div ref={scrollRef}/>
                                    </div>
                                    {(editingMessage || replyingTo) && (
                                        <div className="bg-blue-50/80 border-t border-blue-200/70 p-2 text-xs flex items-center justify-between rounded-b-xl">
                                            <div className="flex-1">
                                                {editingMessage && <span className={messagesDarkMode ? 'text-blue-300' : 'text-blue-700'}>Bearbeite Nachricht...</span>}
                                                {replyingTo && <span className={messagesDarkMode ? 'text-blue-300' : 'text-blue-700'}>Antwort auf: {replyingTo.text || '[Bild]'}</span>}
                                            </div>
                                            <button onClick={() => { editingMessage ? cancelEdit() : cancelReply(); }} className={`${messagesDarkMode ? 'text-gray-400 hover:text-red-300' : 'text-gray-500 hover:text-red-600'}`}>
                                                <X size={14} />
                                            </button>
                                        </div>
                                    )}
                                    <div className="mt-3 pt-3 border-t border-slate-200 flex gap-2 items-center bg-white/80 p-2 rounded-xl shadow-sm">
                                        <button onClick={openCamera} className="cursor-pointer text-slate-500 hover:text-slate-900" title="Foto aufnehmen"><Camera size={20}/></button>
                                        <label className="cursor-pointer text-slate-500 hover:text-slate-900" title="Foto anh√§ngen"><Paperclip size={20}/><input type="file" accept="image/*" className="hidden" onChange={handlePhoto}/></label>
                                        <input ref={inputRef} value={input} onChange={e => setInput(e.target.value)} onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); sendMsg(); } }} className="flex-1 bg-white border border-slate-200 p-2 text-sm text-slate-900 rounded-lg focus:border-blue-500 focus:outline-none" placeholder="Schreibe eine Nachricht..."/>
                                        <button onClick={() => sendMsg()} className="text-white bg-slate-900 px-3 py-1 rounded-lg text-sm font-semibold hover:bg-slate-800">{editingMessage ? 'Speichern' : 'Senden'}</button>
                                    </div>
                                </div>
                            )}
                        </div>
                        <div className={`p-1 text-[10px] text-center border-t ${messagesDarkMode ? 'bg-black text-gray-500 border-slate-800' : 'bg-[#e1e1e1] text-gray-500 border-white'}`}>TimeRoster MSN ¬© 2026</div>
                    </div>
                </div>
            );
        };


        // --- SUB-COMPONENTS ---

        const AuthView = ({ setView }) => {
            const [isRegister, setIsRegister] = useState(false);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');

            const handleAuth = async () => {
                setError('');
                try {
                    if (isRegister) await createUserWithEmailAndPassword(auth, email, password);
                    else await signInWithEmailAndPassword(auth, email, password);
                } catch (e) { setError(e.message); }
            };

            const handleGuest = async () => {
                setError('');
                try { await signInAnonymously(auth); } 
                catch (e) { if(e.code === 'auth/admin-restricted-operation') setError("Gast-Zugang in Firebase Console aktivieren!"); else setError(e.message); }
            };

            return (
                <div className="flex flex-col items-center justify-center min-h-screen p-6 relative z-50">
                    <div className="w-full max-w-sm space-y-6">
                        <h1 className="text-4xl font-bold text-center mb-8 text-white font-cinzel">TimeRoster</h1>
                        <div className="bg-slate-900 p-6 rounded-2xl border border-slate-800 space-y-4 shadow-2xl">
                            <div className="flex bg-slate-800 p-1 rounded-lg">
                                <button onClick={() => setIsRegister(false)} className={`flex-1 py-2 rounded text-white ${!isRegister ? 'bg-blue-600' : 'text-slate-400'}`}>{t('signIn')}</button>
                                <button onClick={() => setIsRegister(true)} className={`flex-1 py-2 rounded text-white ${isRegister ? 'bg-blue-600' : 'text-slate-400'}`}>{t('register')}</button>
                            </div>
                            {error && <div className="bg-red-500/20 text-red-300 p-3 rounded text-xs">{error}</div>}

                            <input type="email" value={email} onChange={e=>setEmail(e.target.value)} className="w-full bg-slate-950 p-3 rounded border border-slate-800 text-white placeholder-slate-500" placeholder="Email" />
                            <input type="password" value={password} onChange={e=>setPassword(e.target.value)} className="w-full bg-slate-950 p-3 rounded border border-slate-800 text-white placeholder-slate-500" placeholder="Passwort" />

                            <button onClick={handleAuth} className="w-full py-3 bg-blue-600 rounded font-bold text-white shadow-lg shadow-blue-900/20">{isRegister ? t('register') : t('signIn')}</button>
                        </div>
                        <button onClick={handleGuest} className="w-full py-3 bg-slate-800 rounded font-bold text-slate-300 hover:bg-slate-700">{t('guest')}</button>
                    </div>
                </div>
            );
        };


        // --- DAY VIEW ---
        const DayView = ({ events, selectedDate, onDateClick, themeClasses, isComic }) => {
            const dateStr = formatDate(selectedDate);
            const dayEvents = getEventsForDate(dateStr, events);
            const hours = Array.from({ length: 24 }, (_, i) => i);

            return (
                <div className="pb-32 h-full flex flex-col">
                    <div className={`flex justify-between items-center p-4 ${themeClasses.calendarHeader}`}>
                        <button onClick={() => {
                            const prev = new Date(selectedDate);
                            prev.setDate(prev.getDate() - 1);
                            onDateClick(prev);
                        }} className="p-2"><ChevronLeft /></button>
                        <h2 className="text-xl font-bold">{selectedDate.toLocaleDateString('de-DE', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })}</h2>
                        <button onClick={() => {
                            const next = new Date(selectedDate);
                            next.setDate(next.getDate() + 1);
                            onDateClick(next);
                        }} className="p-2"><ChevronRight /></button>
                    </div>

                    <div className="flex-1 overflow-y-auto px-4">
                        {hours.map(hour => {
                            const hourStr = String(hour).padStart(2, '0') + ':00';
                            const hourEvents = dayEvents.filter(ev => {
                                const evHour = parseInt(ev.time?.split(':')[0] || '0');
                                return evHour === hour;
                            });

                            return (
                                <div key={hour} className={`border-b ${isComic ? 'border-[#8b5a2b]' : 'border-slate-800'} py-2 flex gap-2`}>
                                    <div className="w-16 text-sm opacity-60 font-mono">{hourStr}</div>
                                    <div className="flex-1 space-y-1">
                                        {hourEvents.map((ev, idx) => {
                                            const cat = CATEGORIES.find(c => c.id === ev.category);
                                            return (
                                                <div key={idx} className={`p-3 rounded-lg cursor-pointer ${isComic ? 'bg-[#f4e4bc] border border-[#8b5a2b]' : 'bg-slate-800'}`}
                                                    onClick={() => onDateClick(selectedDate, ev)}>
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-lg">{cat?.icon}</span>
                                                        <div className="flex-1">
                                                            <div className="font-bold text-sm">{ev.title}</div>
                                                            <div className="text-xs opacity-70">{ev.time}</div>
                                                        </div>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- WEEK VIEW ---
        const WeekView = ({ events, selectedDate, onDateClick, themeClasses, isComic }) => {
            const getWeekDays = (date) => {
                const curr = new Date(date);
                const first = curr.getDate() - curr.getDay() + 1; // Monday
                const days = [];
                for (let i = 0; i < 7; i++) {
                    const day = new Date(curr.setDate(first + i));
                    days.push(new Date(day));
                }
                return days;
            };

            const [weekStart, setWeekStart] = useState(getWeekDays(selectedDate)[0]);
            
            // Update weekStart when selectedDate changes
            useEffect(() => {
                setWeekStart(getWeekDays(selectedDate)[0]);
            }, [selectedDate]);

            const weekDays = getWeekDays(weekStart);

            const goToPrevWeek = () => {
                const prev = new Date(weekStart);
                prev.setDate(prev.getDate() - 7);
                setWeekStart(prev);
            };

            const goToNextWeek = () => {
                const next = new Date(weekStart);
                next.setDate(next.getDate() + 7);
                setWeekStart(next);
            };

            const weekEnd = new Date(weekDays[6]);
            const monthStr = weekStart.getMonth() === weekEnd.getMonth() 
                ? weekStart.toLocaleDateString('de-DE', { month: 'long', year: 'numeric' })
                : `${weekStart.toLocaleDateString('de-DE', { month: 'short' })} - ${weekEnd.toLocaleDateString('de-DE', { month: 'long', year: 'numeric' })}`;

            return (
                <div className="pb-32 h-full flex flex-col">
                    <div className={`flex justify-between items-center p-4 ${themeClasses.calendarHeader}`}>
                        <button onClick={goToPrevWeek} className="p-2"><ChevronLeft /></button>
                        <h2 className="text-xl font-bold">{monthStr}</h2>
                        <button onClick={goToNextWeek} className="p-2"><ChevronRight /></button>
                    </div>

                    <div className="flex-1 overflow-y-auto">
                        <div className="grid grid-cols-7 gap-1 p-2">
                            {['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'].map((day, idx) => (
                                <div key={idx} className="text-center text-xs font-bold opacity-60 mb-2">{day}</div>
                            ))}
                        </div>
                        <div className="grid grid-cols-7 gap-1 p-2">
                            {weekDays.map((day, idx) => {
                                const dateStr = formatDate(day);
                                const dayEvents = getEventsForDate(dateStr, events);
                                const isToday = dateStr === formatDate(new Date());

                                return (
                                    <div key={idx} 
                                        className={`p-2 rounded-lg cursor-pointer min-h-[100px] ${isToday ? 'ring-2 ring-blue-500' : ''} ${isComic ? 'bg-[#f4e4bc] border border-[#8b5a2b]' : 'bg-slate-800'}`}
                                        onClick={() => onDateClick(day)}>
                                        <div className={`text-sm font-bold mb-1 ${isToday ? 'text-blue-400' : ''}`}>
                                            {day.getDate()}
                                        </div>
                                        <div className="space-y-1">
                                            {dayEvents.slice(0, 3).map((ev, evIdx) => {
                                                const cat = CATEGORIES.find(c => c.id === ev.category);
                                                return (
                                                    <div key={evIdx} className="text-[9px] truncate flex items-center gap-1">
                                                        <span>{cat?.icon}</span>
                                                        <span className="truncate">{ev.title}</span>
                                                    </div>
                                                );
                                            })}
                                            {dayEvents.length > 3 && (
                                                <div className="text-[8px] opacity-60">+{dayEvents.length - 3}</div>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const CalendarView = ({ events, shifts, schedule, assignShift, onDateClick, onDateLongPress, viewingFriend, viewingFriendName, onSecretTrigger, themeClasses, isComic, currentUserId, secretPremiumUnlocked }) => {
            const [currentDate, setCurrentDate] = useState(new Date());
            const [isPaintMode, setIsPaintMode] = useState(false);
            const [paintShiftId, setPaintShiftId] = useState(shifts[0]?.id || 'off'); 
            const [isDragging, setIsDragging] = useState(false);
            const titleTimer = useRef(null);
            const [pulseTitle, setPulseTitle] = useState(false);

            // Filter events based on viewing mode
            const filteredEvents = useMemo(() => {
                if (!viewingFriend) {
                    // Own calendar - show all events
                    return events;
                }
                // Friend's calendar - only show approved events, or pending events created by current user
                return events.filter(ev => 
                    !ev.status || ev.status === 'approved' || (ev.status === 'pending' && ev.createdBy === (typeof currentUserId!=='undefined' ? currentUserId : (auth?.currentUser?.uid || null)))
                );
            }, [events, viewingFriend, auth?.currentUser?.uid]);

            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const daysInMonth = getDaysInMonth(year, month);
            const startOffset = getFirstDayOfMonth(year, month) === 0 ? 6 : getFirstDayOfMonth(year, month) - 1; 
            const days = [];
            for(let i=0; i<startOffset; i++) days.push(null);
            for(let i=1; i<=daysInMonth; i++) days.push(new Date(year, month, i));

            const monthStats = useMemo(() => {
                const stats = {};
                shifts.forEach(s => stats[s.id] = 0);
                days.forEach(d => {
                    if (d) {
                        const sId = schedule[formatDate(d)];
                        if (sId && stats[sId] !== undefined) stats[sId]++;
                    }
                });
                return stats;
            }, [schedule, month, shifts]);

            const handleTouchMove = (e) => {
                if (!isPaintMode || !isDragging || viewingFriend) return;
                const t = e.touches[0];
                const target = document.elementFromPoint(t.clientX, t.clientY);
                if (target) {
                    const cell = target.closest('[data-date]');
                    if (cell) {
                        const dateStr = cell.getAttribute('data-date');
                        if (dateStr) assignShift(dateStr, paintShiftId === 'eraser' ? null : paintShiftId);
                    }
                }
            };

            const handlePaintStart = (dateStr) => { if(isPaintMode && !viewingFriend) { setIsDragging(true); assignShift(dateStr, paintShiftId === 'eraser' ? null : paintShiftId); } };
            const handlePaintEnter = (dateStr) => { if(isPaintMode && isDragging && !viewingFriend) assignShift(dateStr, paintShiftId === 'eraser' ? null : paintShiftId); };

            const handleTitleDown = () => { setPulseTitle(true); titleTimer.current = setTimeout(() => { onSecretTrigger(); setPulseTitle(false); }, 3000); };
            const handleTitleUp = () => { if (titleTimer.current) clearTimeout(titleTimer.current); setPulseTitle(false); };

            return (
                <div className="pb-32 select-none h-full flex flex-col" onPointerUp={()=>setIsDragging(false)} onMouseLeave={()=>setIsDragging(false)}>
                    <div className={`flex justify-between items-center p-4 ${themeClasses.calendarHeader}`}>
                        <button onClick={() => setCurrentDate(new Date(year, month - 1, 1))} className="p-2"><ChevronLeft /></button>
                        <div 
                            className={`flex flex-col items-center cursor-pointer active:scale-95 transition-all select-none ${pulseTitle ? 'animate-pulse-soft text-blue-400' : ''}`}
                            onMouseDown={handleTitleDown} onMouseUp={handleTitleUp} onMouseLeave={handleTitleUp} onTouchStart={handleTitleDown} onTouchEnd={handleTitleUp}
                        >
                            {viewingFriendName && <span className="text-sm opacity-70">Kalender von {viewingFriendName}</span>}
                            <h2 className="text-xl font-bold">{currentDate.toLocaleDateString('de-DE', { month: 'long', year: 'numeric' })}</h2>
                            <span className="text-xs opacity-60 flex items-center gap-1"><BarChart2 size={10}/> {shifts.reduce((acc,s)=>acc+(monthStats[s.id]||0),0)} Schichten</span>
                        </div>
                        <button onClick={() => setCurrentDate(new Date(year, month + 1, 1))} className="p-2"><ChevronRight /></button>
                    </div>

                    {!viewingFriend && (
                        <div className={`px-4 py-2 flex items-center justify-between gap-2 overflow-x-auto ${themeClasses.calendarToolbar}`}>
                            <button onClick={() => setIsPaintMode(!isPaintMode)} className={`p-2 rounded-lg flex items-center gap-2 text-xs font-bold transition-all ${isPaintMode ? 'bg-blue-600 text-white' : 'opacity-60'}`}><Edit3 size={14}/> {t('paintMode')}</button>
                            {isPaintMode && (
                                <div className="flex gap-1">
                                    <button onClick={() => setPaintShiftId('eraser')} className={`w-8 h-8 rounded-full border-2 flex items-center justify-center transition-all bg-slate-700/50 ${paintShiftId==='eraser' ? 'border-red-500 scale-110' : 'border-transparent opacity-50'}`}><Eraser size={14} className={paintShiftId==='eraser' ? 'text-red-400' : 'text-slate-400'}/></button>
                                    {shifts.map(s => <button key={s.id} onClick={() => setPaintShiftId(s.id)} className={`w-8 h-8 rounded-full border-2 flex items-center justify-center ${paintShiftId===s.id ? 'border-white scale-110 shadow-md' : 'border-transparent opacity-50'}`} style={{ backgroundColor: s.color }}>{paintShiftId === s.id && <CheckCircle size={14} className="text-white mix-blend-difference"/>}</button>)}
                                </div>
                            )}
                        </div>
                    )}

                    <div className={`grid grid-cols-7 text-center py-2 text-xs opacity-70 font-bold ${themeClasses.calendarWeek}`}>{['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'].map(d => <div key={d}>{d}</div>)}</div>
                    <div className="grid grid-cols-7 gap-1 px-2 touch-none flex-1 overflow-y-auto" style={{ touchAction: isPaintMode ? 'none' : 'auto' }} onTouchMove={handleTouchMove}>
                        {days.map((date, idx) => {
                            if (!date) return <div key={idx} className="aspect-square"></div>;
                            const dateStr = formatDate(date);
                            const shiftId = schedule[dateStr];
                            const shift = shifts.find(s => s.id === shiftId);
                            const dayEvents = getEventsForDate(dateStr, filteredEvents);
                            const isToday = dateStr === formatDate(new Date());
                            return (
                                <div key={idx} data-date={dateStr}
                                    onPointerDown={() => handlePaintStart(dateStr)} onPointerEnter={() => handlePaintEnter(dateStr)}
                                    onClick={() => { if(!isPaintMode && !viewingFriend) { const idx = shifts.findIndex(s=>s.id === (shiftId||'off')); assignShift(dateStr, shifts[(idx+1)%shifts.length].id); } }}
                                    onContextMenu={(e) => { e.preventDefault(); onDateLongPress(date); }}
                                    className={`aspect-square relative rounded-lg flex flex-col items-center justify-start pt-1 transition-all active:scale-95 cursor-pointer ${isToday ? 'border-2 border-blue-500 bg-blue-500/10' : themeClasses.calendarCell}`}
                                    style={{ backgroundColor: shift ? shift.color + '80' : undefined }}
                                >
                                    <span className={`text-sm ${isToday ? 'font-bold' : ''}`}>{date.getDate()}</span>
                                    <div className="flex gap-0.5 mt-1 flex-wrap justify-center h-2 overflow-hidden">{dayEvents.slice(0,3).map((ev, i) => <div key={i} className="w-1.5 h-1.5 rounded-full" style={{ backgroundColor: CATEGORIES.find(c => c.id === ev.category)?.color }}></div>)}</div>
                                    {shift && shift.id !== 'off' && <span className="text-[9px] mt-auto mb-1 opacity-80 leading-tight truncate px-1">{shift.name.substring(0,2)}</span>}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        const FriendsView = ({ user, themeClasses, isComic, currentShareCode, currentUserName, onSelectFriend }) => {
            const [friendCode, setFriendCode] = useState('');
            const [friends, setFriends] = useState([]);
            const [requests, setRequests] = useState([]);
            const [loading, setLoading] = useState(false);

            useEffect(() => {
                if(!user) return;
                const unsub = onSnapshot(collection(db, 'artifacts', appId, 'users', user.uid, 'friends'), (snap) => {
                    const reqs = [], fris = [];
                    snap.forEach(doc => {
                        const d = doc.data();
                        if (d.status === 'pending_received') reqs.push({ id: doc.id, ...d });
                        else if (d.status === 'accepted') fris.push({ id: doc.id, ...d });
                    });
                    setRequests(reqs); setFriends(fris);
                }, err => console.error("Friends Error", err));
                return () => unsub();
            }, [user]);

                        const addFriend = async () => {
                const code = (friendCode || '').trim();
                if(!code) return;
                setLoading(true);
                try {
                    const snap = await getDoc(doc(db, 'artifacts', appId, 'public_profiles', code));
                    if (!snap.exists()) { alert("Code nicht gefunden"); setLoading(false); return; }
                    const profileData = snap.data();
                    const fid = profileData.userId;
                    const friendName = profileData.name || 'Friend';
                    if(fid === user.uid) { setLoading(false); return alert("Das bist du!"); }
                    const myName = (currentUserName || '').trim() || getUserName(user);
                    const batch = writeBatch(db);
                    batch.set(doc(db, 'artifacts', appId, 'users', user.uid, 'friends', fid), { status: 'pending_sent', shareCode: code, name: friendName });
                    batch.set(doc(db, 'artifacts', appId, 'users', fid, 'friends', user.uid), { status: 'pending_received', shareCode: currentShareCode, name: myName });
                    await batch.commit();
                    alert("Anfrage gesendet!"); setFriendCode('');
                } catch(e) { console.error(e); alert("Fehler beim Hinzuf√ºgen."); }
                setLoading(false);
            };


            const accept = async (fid) => {
                const batch = writeBatch(db);
                batch.update(doc(db, 'artifacts', appId, 'users', user.uid, 'friends', fid), { status: 'accepted' });
                batch.update(doc(db, 'artifacts', appId, 'users', fid, 'friends', user.uid), { status: 'accepted' });
                await batch.commit();
            };

            return (
                <div className="p-4 space-y-6 pb-32">
                    <div className={`p-6 rounded-2xl text-center ${themeClasses.card}`}>
                        <h2 className="text-xl font-bold mb-2">{t('shareCode')}</h2>
                        <div className="text-3xl font-mono tracking-widest text-blue-400 select-all font-bold bg-black/20 p-2 rounded">{currentShareCode || "..."}</div>
                    </div>
                    <div className="space-y-2">
                        <label className="text-xs font-bold opacity-70 uppercase">{t('addFriend')}</label>
                        <div className="flex gap-2">
                            <input value={friendCode} onChange={e=>setFriendCode(e.target.value)} placeholder="rai123456" className={`flex-1 p-3 rounded-xl outline-none ${themeClasses.input}`}/>
                            <button onClick={addFriend} disabled={loading} className={`p-3 rounded-xl ${themeClasses.button}`}><Plus/></button>
                        </div>
                    </div>
                    {requests.length > 0 && <div className="space-y-2"><label className="text-xs font-bold opacity-70 uppercase text-orange-400">{t('pendingRequests')}</label>{requests.map(r=><div key={r.id} className={`p-4 rounded-xl flex items-center justify-between ${isComic?'bg-[#fdf6e3]':themeClasses.listItem}`}><div className="flex flex-col"><span className="font-bold">{r.name || r.shareCode}</span><span className="text-xs opacity-60 font-mono">{r.shareCode}</span></div><button onClick={()=>accept(r.id)} className="bg-green-600 text-white p-2 rounded text-xs font-bold">{t('accept')}</button></div>)}</div>}
                    <div className="space-y-2"><label className="text-xs font-bold opacity-70 uppercase">{t('myFriends')}</label>{friends.length===0?<p className="opacity-40 text-sm">Keine Freunde.</p>:friends.map(f=><div key={f.id} className={`p-4 rounded-xl flex items-center justify-between ${isComic?'bg-[#fdf6e3]':themeClasses.listItem}`}><div className="flex items-center gap-3"><div className="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white"><User size={16}/></div><div className="flex flex-col"><span className="font-bold">{f.name || f.shareCode}</span><span className="text-xs opacity-60 font-mono">{f.shareCode}</span></div></div><button onClick={()=>onSelectFriend(f.id)} className="p-2 rounded-full bg-blue-500/20 text-blue-400"><Eye size={20}/></button></div>)}</div>
                </div>
            );
        };

        // --- SETTINGS COMPONENT ---
        const SettingsView = ({ theme, setTheme, lang, setLang, fontScale, setFontScale, currentFont, setCurrentFont, shifts, saveShiftConfig, deleteShift, signOut, themeClasses, user, shareCode, displayName, setDisplayName, onSaveDisplayName }) => {
            const [openSection, setOpenSection] = useState(null);
            const [editingShiftId, setEditingShiftId] = useState('');
            const [editForm, setEditForm] = useState({ name: '', start: '', end: '', color: '#000000' });

            const toggle = (s) => setOpenSection(openSection === s ? null : s);
            const fonts = [ { id: 'font-inter', name: t('fontModern') }, { id: 'font-cinzel', name: t('fontAntique') }, { id: 'font-playfair', name: t('fontElegant') }, { id: 'font-merriweather', name: t('fontReadable') }, { id: 'font-oswald', name: t('fontStrong') } ];

            const [nameDraft, setNameDraft] = useState(displayName || '');
            useEffect(() => { setNameDraft(displayName || ''); }, [displayName]);

            return (
                <div className="p-4 pb-32 space-y-4 h-full overflow-y-auto">
                    <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}>
                        <button onClick={() => toggle('profile')} className="w-full p-4 flex justify-between items-center font-bold"><span className="flex items-center gap-2"><User size={18}/> Profil</span>{openSection==='profile'?<ChevronLeft className="-rotate-90"/>:<ChevronLeft className="rotate-0"/>}</button>
                        {openSection === 'profile' && (
                            <div className="p-4 pt-0 space-y-3 border-t border-black/10">
                                <div>
                                    <label className="text-xs opacity-70 block mb-1 font-bold">Dein Name (sichtbar f√ºr Freunde)</label>
                                    <input value={nameDraft} onChange={(e)=>setNameDraft(e.target.value)} placeholder="z.B. Leo" className="w-full p-3 rounded-lg bg-black/30 border border-white/10 outline-none" />
                                </div>
                                <div className="text-xs opacity-70">Freundes-Code: <span className="font-bold">{shareCode || '-'}</span></div>
                                <button onClick={() => onSaveDisplayName(nameDraft)} className="w-full p-3 rounded-lg bg-blue-600/30 border border-blue-500 font-bold">Name speichern</button>
                            </div>
                        )}
                    </div>
                    <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}>
                        <button onClick={() => toggle('appearance')} className="w-full p-4 flex justify-between items-center font-bold"><span className="flex items-center gap-2"><Layout size={18}/> {t('appearance')}</span>{openSection==='appearance'?<ChevronLeft className="-rotate-90"/>:<ChevronLeft className="rotate-0"/>}</button>
                        {openSection === 'appearance' && (
                            <div className="p-4 pt-0 space-y-4 border-t border-black/10">
                                
                                <div className="mt-4 grid grid-cols-2 gap-2">
                                    <button onClick={() => setTheme('noble')} className={`p-3 rounded-lg border-2 font-bold ${theme === 'noble' ? 'border-blue-500 bg-blue-500/10' : 'border-transparent opacity-80'}`}>{t('noble')}</button>
                                    <button onClick={() => setTheme('amoled')} className={`p-3 rounded-lg border-2 font-bold ${theme === 'amoled' ? 'border-blue-500 bg-blue-500/10' : 'border-transparent opacity-80'}`}>{t('amoled')}</button>
                                    <button onClick={() => setTheme('mono')} className={`p-3 rounded-lg border-2 font-bold ${theme === 'mono' ? 'border-blue-500 bg-blue-500/10' : 'border-transparent opacity-80'}`}>{t('mono')}</button>
                                    <button onClick={() => setTheme('comic')} className={`p-3 rounded-lg border-2 font-bold ${theme === 'comic' ? 'border-[#8b5a2b] bg-[#8b5a2b]/10' : 'border-transparent opacity-80'}`}>{t('comic')}</button>
                                </div>

                                <div><label className="text-xs opacity-60 block mb-2 font-bold uppercase">{t('font')}</label><select value={currentFont} onChange={(e) => setCurrentFont(e.target.value)} className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}>{fonts.map(f => <option key={f.id} value={f.id}>{f.name}</option>)}</select></div>
                                <div><label className="text-xs opacity-60 block mb-2 font-bold uppercase">{t('fontSize')}: {Math.round(fontScale * 100)}%</label><input type="range" min="0.8" max="1.3" step="0.05" value={fontScale} onChange={(e) => setFontScale(parseFloat(e.target.value))} className="w-full accent-blue-500"/></div>
                            </div>
                        )}
                    </div>
                    <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}>
                        <button onClick={() => toggle('shifts')} className="w-full p-4 flex justify-between items-center font-bold"><span className="flex items-center gap-2"><Clock size={18}/> {t('manageShifts')}</span>{openSection==='shifts'?<ChevronLeft className="-rotate-90"/>:<ChevronLeft className="rotate-0"/>}</button>
                        {openSection === 'shifts' && (
                            <div className="p-4 pt-0 border-t border-black/10">
                                <div className="mt-4">
                                    <select value={editingShiftId} onChange={(e) => { const sId = e.target.value; setEditingShiftId(sId); if (sId === 'new') setEditForm({ name: '', start: '', end: '', color: '#3b82f6' }); else { const s = shifts.find(x => x.id === sId); if(s) setEditForm({...s}); } }} className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}><option value="">-- {t('selectShift')} --</option><option value="new">+ {t('newShift')}</option>{shifts.map(s => <option key={s.id} value={s.id}>{s.name}</option>)}</select>
                                </div>
                                {editingShiftId && (
                                    <div className="mt-4 space-y-3 bg-black/5 p-3 rounded-lg">
                                        <input value={editForm.name} onChange={e => setEditForm({...editForm, name: e.target.value})} className={`w-full p-2 rounded-md ${themeClasses.input}`} />
                                        <div className="grid grid-cols-2 gap-2"><input type="time" value={editForm.start} onChange={e => setEditForm({...editForm, start: e.target.value})} className={`w-full p-2 rounded-md ${themeClasses.input}`}/><input type="time" value={editForm.end} onChange={e => setEditForm({...editForm, end: e.target.value})} className={`w-full p-2 rounded-md ${themeClasses.input}`}/></div>
                                        <div className="flex items-center gap-2"><input type="color" value={editForm.color} onChange={e => setEditForm({...editForm, color: e.target.value})} className="h-10 w-10 rounded border-none"/></div>
                                        <div className="flex gap-2 pt-2">{editingShiftId !== 'new' && <button onClick={() => { deleteShift(editingShiftId); setEditingShiftId(''); }} className="p-3 bg-red-500/20 text-red-500 rounded-lg"><Trash2 size={18}/></button>}<button onClick={async () => { const newShift = { ...editForm, id: editingShiftId === 'new' ? crypto.randomUUID() : editingShiftId }; await saveShiftConfig(newShift); setEditingShiftId(''); }} className={`flex-1 p-3 rounded-lg font-bold ${themeClasses.button}`}>{t('save')}</button></div>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                    <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}><button onClick={() => signOut(auth)} className="w-full p-4 flex items-center justify-center gap-2 text-red-400 font-bold"><LogOut size={18}/> Logout</button></div>
                </div>
            );
        };

        const EventDetailModal = ({ event, onClose, onSave, onDelete, themeClasses, isComic, user, onUpdateParticipantStatus }) => {
            const currentUserId = user?.uid || null;
            if (!event) return null;
            const [isEditing, setIsEditing] = useState(false);
            const [formData, setFormData] = useState({ ...event });
            const [tasks, setTasks] = useState(event.tasks || []);
            const [newTaskTitle, setNewTaskTitle] = useState('');
            const [newTaskDueDate, setNewTaskDueDate] = useState('');
            const [newTaskResponsible, setNewTaskResponsible] = useState('');
            const [newTaskStatus, setNewTaskStatus] = useState('open');
            const [newTaskPriority, setNewTaskPriority] = useState('normal');
            const [newTaskReminder, setNewTaskReminder] = useState('');
            const [newSubtaskText, setNewSubtaskText] = useState({});
            
            const handleSave = () => { 
                onSave({ ...formData, tasks, id: event.id }); 
                setIsEditing(false); 
            }
            
            const addTask = () => {
                if (!newTaskTitle.trim()) return;
                const newTask = {
                    id: `task_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
                    title: newTaskTitle,
                    dueDate: newTaskDueDate,
                    responsible: newTaskResponsible,
                    status: newTaskStatus,
                    priority: newTaskPriority,
                    reminder: newTaskReminder,
                    checklist: []
                };
                setTasks([...tasks, newTask]);
                setNewTaskTitle('');
                setNewTaskDueDate('');
                setNewTaskResponsible('');
                setNewTaskStatus('open');
                setNewTaskPriority('normal');
                setNewTaskReminder('');
            };
            
            const deleteTask = (taskId) => {
                setTasks(tasks.filter(t => t.id !== taskId));
            };
            
            const updateTask = (taskId, updates) => {
                setTasks(tasks.map(t => t.id === taskId ? { ...t, ...updates } : t));
            };
            
            const addSubtask = (taskId) => {
                const text = newSubtaskText[taskId];
                if (!text || !text.trim()) return;
                const task = tasks.find(t => t.id === taskId);
                if (!task) return;
                const newSubtask = {
                    id: `subtask_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
                    text: text,
                    completed: false
                };
                updateTask(taskId, { checklist: [...(task.checklist || []), newSubtask] });
                setNewSubtaskText({ ...newSubtaskText, [taskId]: '' });
            };
            
            const toggleSubtask = (taskId, subtaskId) => {
                const task = tasks.find(t => t.id === taskId);
                if (!task) return;
                const updatedChecklist = task.checklist.map(s => 
                    s.id === subtaskId ? { ...s, completed: !s.completed } : s
                );
                updateTask(taskId, { checklist: updatedChecklist });
            };
            
            const deleteSubtask = (taskId, subtaskId) => {
                const task = tasks.find(t => t.id === taskId);
                if (!task) return;
                updateTask(taskId, { checklist: task.checklist.filter(s => s.id !== subtaskId) });
            };
            
            // Get current user's participant status
            const currentUserParticipant = user?.uid ? (event.participants || []).find(p => p.userId === user.uid) : null;
            const currentUserStatus = currentUserParticipant?.status || 'pending';
            
            const handleResponseStatusChange = (newStatus) => {
                // Validate status value
                const validStatuses = ['accepted', 'maybe', 'declined', 'pending'];
                if (!validStatuses.includes(newStatus)) {
                    console.error('Invalid status value:', newStatus);
                    return;
                }
                
                if (onUpdateParticipantStatus && user) {
                    onUpdateParticipantStatus(event.id, user.uid, newStatus);
                }
            };
            const isPending = event.status === 'pending';
            const isCreatedByOther = event.createdBy && event.createdBy !== currentUserId;

            return (
                <div className="fixed inset-0 z-50 flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm p-4 text-white">
                    <div className={`w-full max-w-md rounded-2xl p-6 ${isComic?'bg-[#f4e4bc] border-4 border-[#8b5a2b] text-[#4a3b2a]':'bg-slate-900 border border-slate-700'}`}>
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-bold">{isEditing ? t('editEvent') : t('eventDetails')}</h2>
                            <div className="flex gap-2">
                                {!isEditing && <button onClick={() => setIsEditing(true)} className="p-2 bg-blue-500/20 text-blue-400 rounded-lg"><Pencil size={18}/></button>}
                                <button onClick={onClose}><X /></button>
                            </div>
                        </div>
                        {isEditing ? (
                            <div className="space-y-4">
                                <div>
                                    <label className="text-xs opacity-70 block mb-1 font-bold">{t('category')}</label>
                                    <div className="grid grid-cols-5 gap-2">{CATEGORIES.map(cat => <button key={cat.id} onClick={() => setFormData({...formData, category: cat.id})} className={`p-2 rounded-lg flex flex-col items-center gap-1 transition-all ${formData.category === cat.id ? 'bg-blue-600/30 border border-blue-500' : 'opacity-60'}`}><span className="text-xl">{cat.icon}</span><span className="text-[9px]">{t(cat.id)}</span></button>)}</div>
                                </div>
                                <input value={formData.title} onChange={e => setFormData({...formData, title: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`} />
                                <div className="grid grid-cols-2 gap-2"><input type="date" value={formData.date} onChange={e => setFormData({...formData, date: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`}/><input type="time" value={formData.time} onChange={e => setFormData({...formData, time: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`}/></div>
                                <div>
                                    <label className="text-xs opacity-70 block mb-1 font-bold">{t('repeat')}</label>
                                    <select value={formData.repeat || 'none'} onChange={e => setFormData({...formData, repeat: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}>
                                        <option value="none">{t('repeatNone')}</option>
                                        <option value="daily">{t('repeatDaily')}</option>
                                        <option value="weekly">{t('repeatWeekly')}</option>
                                        <option value="monthly">{t('repeatMonthly')}</option>
                                        <option value="yearly">{t('repeatYearly')}</option>
                                    </select>
                                </div>
                                <input value={formData.location || ''} onChange={e => setFormData({...formData, location: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`} placeholder={t('location')}/>
                                <div>
                                    <label className="text-xs opacity-70 block mb-1 font-bold">{t('timezone')}</label>
                                    <select value={formData.timezone || 'Europe/Berlin'} onChange={e => setFormData({...formData, timezone: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}>
                                        {TIMEZONES.map(tz => <option key={tz} value={tz}>{tz}</option>)}
                                    </select>
                                </div>

                                <div className="flex gap-2 pt-2"><button onClick={() => onDelete(event.id)} className="p-3 bg-red-500/20 text-red-500 rounded-lg"><Trash2 size={18}/></button><button onClick={handleSave} className={`flex-1 p-3 rounded-lg font-bold ${themeClasses.button}`}>{t('save')}</button></div>
                            </div>
                        ) : (
                            <div className="space-y-4">
                                <div className="flex items-center gap-4 p-4 bg-black/10 rounded-xl">
                                    <div className="text-3xl">{CATEGORIES.find(c => c.id === event.category)?.icon}</div>
                                    <div><h3 className="font-bold text-lg">{t(event.category)}</h3><p className="opacity-80 text-sm">{event.title}</p></div>
                                </div>
                                <div className="flex items-center gap-2 opacity-70"><Clock size={16}/> {(event._occDate || event.date)} um {event.time}</div>
                                {event._occDate && event._occDate !== event.date && <div className="text-xs opacity-60">Basisdatum: {event.date} (Serie)</div>}
                                {(event.repeat && event.repeat !== 'none') && (
                                    <div className="flex items-center gap-2 opacity-70">
                                        <Repeat size={16}/> {t('repeat')}: {t(event.repeat === 'daily' ? 'repeatDaily' : event.repeat === 'weekly' ? 'repeatWeekly' : event.repeat === 'monthly' ? 'repeatMonthly' : 'repeatYearly')}
                                    </div>
                                )}

                                {event.location && <div className="flex items-center gap-2 opacity-70"><MapPin size={16}/> {event.location}</div>}
                                {event.timezone && <div className="flex items-center gap-2 opacity-70"><Globe size={16}/> {event.timezone}</div>}
                                
                                {/* Invitees Section */}
                                {event.participants && event.participants.length > 0 && (
                                    <div className="mt-4 pt-4 border-t border-slate-700/50">
                                        <h3 className="text-sm font-bold opacity-70 mb-3 uppercase">{t('invitees')}</h3>
                                        <div className="space-y-2">
                                            {event.participants.map((participant, idx) => {
                                                const isOrganizer = participant.userId === event.createdBy;
                                                const isCurrentUser = participant.userId === currentUserId;
                                                const canOrganizerUpdateParticipant = event.createdBy === currentUserId && !isOrganizer && participant.userId;
                                                const statusColors = {
                                                    accepted: 'text-green-400 bg-green-500/10',
                                                    declined: 'text-red-400 bg-red-500/10',
                                                    maybe: 'text-yellow-400 bg-yellow-500/10',
                                                    pending: 'text-gray-400 bg-gray-500/10'
                                                };
                                                const statusLabels = {
                                                    accepted: t('going'),
                                                    declined: t('declined'),
                                                    maybe: t('maybe'),
                                                    pending: t('noResponse')
                                                };
                                                
                                                return (
                                                    <div key={participant.userId || participant.email || `participant-${idx}`} className={`flex items-center justify-between p-3 rounded-lg ${isComic ? 'bg-[#fdf6e3]' : 'bg-black/20'}`}>
                                                        <div className="flex items-center gap-2 flex-1">
                                                            <div className="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white text-xs font-bold">
                                                                {(participant.userName || participant.email || 'U').charAt(0).toUpperCase()}
                                                            </div>
                                                            <div className="flex flex-col flex-1">
                                                                <span className="text-sm font-semibold">
                                                                    {participant.userName || participant.email || 'Unknown'}
                                                                    {isOrganizer && <span className="ml-2 text-xs opacity-60">({t('organizer')})</span>}
                                                                </span>
                                                                {participant.email && participant.userName && (
                                                                    <span className="text-xs opacity-60">{participant.email}</span>
                                                                )}
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center gap-2">
                                                            {isCurrentUser && !isOrganizer ? (
                                                                <select 
                                                                    value={currentUserStatus}
                                                                    onChange={(e) => handleResponseStatusChange(e.target.value)}
                                                                    className={`text-xs px-2 py-1 rounded ${statusColors[currentUserStatus] || statusColors.pending} outline-none cursor-pointer`}
                                                                >
                                                                    <option value="accepted">{t('going')}</option>
                                                                    <option value="maybe">{t('maybe')}</option>
                                                                    <option value="declined">{t('declined')}</option>
                                                                </select>
                                                            ) : canOrganizerUpdateParticipant ? (
                                                                <select 
                                                                    value={participant.status || 'pending'}
                                                                    onChange={(e) => onUpdateParticipantStatus(event.id, participant.userId, e.target.value)}
                                                                    className={`text-xs px-2 py-1 rounded ${statusColors[participant.status] || statusColors.pending} outline-none cursor-pointer`}
                                                                >
                                                                    <option value="accepted">{t('going')}</option>
                                                                    <option value="maybe">{t('maybe')}</option>
                                                                    <option value="declined">{t('declined')}</option>
                                                                    <option value="pending">{t('noResponse')}</option>
                                                                </select>
                                                            ) : (
                                                                <span className={`text-xs px-2 py-1 rounded ${statusColors[participant.status] || statusColors.pending}`}>
                                                                    {statusLabels[participant.status] || statusLabels.pending}
                                                                </span>
                                                            )}
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                )}
                                
                                {/* Tasks Section */}
                                <div className="mt-4 pt-4 border-t border-slate-700/50">
                                    <h3 className="text-sm font-bold opacity-70 mb-3 uppercase">{t('tasks')}</h3>
                                    
                                    {/* Task List */}
                                    {tasks.length === 0 ? (
                                        <div className="text-sm opacity-60 text-center py-2">{t('noTasks')}</div>
                                    ) : (
                                        <div className="space-y-3 mb-4">
                                            {tasks.map((task) => {
                                                const statusColors = {
                                                    open: 'text-blue-400 bg-blue-500/10',
                                                    inProgress: 'text-yellow-400 bg-yellow-500/10',
                                                    completed: 'text-green-400 bg-green-500/10'
                                                };
                                                const priorityColors = {
                                                    high: 'border-red-500',
                                                    normal: 'border-slate-700',
                                                    low: 'border-gray-600'
                                                };
                                                
                                                return (
                                                    <div key={task.id} className={`p-3 rounded-lg border-2 ${priorityColors[task.priority] || priorityColors.normal} ${isComic ? 'bg-[#fdf6e3]' : 'bg-black/20'}`}>
                                                        <div className="flex items-start justify-between mb-2">
                                                            <div className="flex-1">
                                                                <div className="font-semibold text-sm">{task.title}</div>
                                                                {task.dueDate && (
                                                                    <div className="text-xs opacity-60 mt-1">
                                                                        <Clock size={12} className="inline mr-1" />
                                                                        {task.dueDate}
                                                                    </div>
                                                                )}
                                                                {task.responsible && (
                                                                    <div className="text-xs opacity-60 mt-1">
                                                                        <User size={12} className="inline mr-1" />
                                                                        {task.responsible}
                                                                    </div>
                                                                )}
                                                                {task.reminder && (
                                                                    <div className="text-xs opacity-60 mt-1">
                                                                        <Bell size={12} className="inline mr-1" />
                                                                        {task.reminder}
                                                                    </div>
                                                                )}
                                                            </div>
                                                            <div className="flex items-center gap-2">
                                                                <button 
                                                                    onClick={() => deleteTask(task.id)}
                                                                    className="text-red-400 hover:text-red-300 p-1"
                                                                >
                                                                    <Trash2 size={14} />
                                                                </button>
                                                            </div>
                                                        </div>
                                                        
                                                        {/* Task Status and Priority */}
                                                        <div className="flex gap-2 mb-2">
                                                            <select 
                                                                value={task.status}
                                                                onChange={(e) => updateTask(task.id, { status: e.target.value })}
                                                                className={`text-xs px-2 py-1 rounded ${statusColors[task.status] || statusColors.open} outline-none cursor-pointer`}
                                                            >
                                                                <option value="open">{t('statusOpen')}</option>
                                                                <option value="inProgress">{t('statusInProgress')}</option>
                                                                <option value="completed">{t('statusCompleted')}</option>
                                                            </select>
                                                            <select 
                                                                value={task.priority}
                                                                onChange={(e) => updateTask(task.id, { priority: e.target.value })}
                                                                className="text-xs px-2 py-1 rounded bg-black/20 outline-none cursor-pointer"
                                                            >
                                                                <option value="high">{t('priorityHigh')}</option>
                                                                <option value="normal">{t('priorityNormal')}</option>
                                                                <option value="low">{t('priorityLow')}</option>
                                                            </select>
                                                        </div>
                                                        
                                                        {/* Checklist */}
                                                        {task.checklist && task.checklist.length > 0 && (
                                                            <div className="mt-2 space-y-1">
                                                                {task.checklist.map((item) => (
                                                                    <div key={item.id} className="flex items-center gap-2 text-xs">
                                                                        <input 
                                                                            type="checkbox" 
                                                                            checked={item.completed}
                                                                            onChange={() => toggleSubtask(task.id, item.id)}
                                                                            className="cursor-pointer"
                                                                        />
                                                                        <span className={item.completed ? 'line-through opacity-50' : ''}>{item.text}</span>
                                                                        <button 
                                                                            onClick={() => deleteSubtask(task.id, item.id)}
                                                                            className="text-red-400 hover:text-red-300 ml-auto"
                                                                        >
                                                                            <X size={12} />
                                                                        </button>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        )}
                                                        
                                                        {/* Add Subtask */}
                                                        <div className="mt-2 flex gap-1">
                                                            <input 
                                                                type="text"
                                                                value={newSubtaskText[task.id] || ''}
                                                                onChange={(e) => setNewSubtaskText({ ...newSubtaskText, [task.id]: e.target.value })}
                                                                onKeyPress={(e) => e.key === 'Enter' && addSubtask(task.id)}
                                                                placeholder={t('addSubtask')}
                                                                className={`flex-1 px-2 py-1 text-xs rounded outline-none ${themeClasses.input}`}
                                                            />
                                                            <button 
                                                                onClick={() => addSubtask(task.id)}
                                                                className="px-2 py-1 bg-blue-500/20 text-blue-400 rounded text-xs"
                                                            >
                                                                <Plus size={14} />
                                                            </button>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    )}
                                    
                                    {/* Add New Task Form */}
                                    <div className={`p-3 rounded-lg ${isComic ? 'bg-[#fdf6e3]' : 'bg-black/10'} space-y-2`}>
                                        <input 
                                            type="text"
                                            value={newTaskTitle}
                                            onChange={(e) => setNewTaskTitle(e.target.value)}
                                            placeholder={t('taskTitle')}
                                            className={`w-full px-2 py-2 text-sm rounded outline-none ${themeClasses.input}`}
                                        />
                                        <div className="grid grid-cols-2 gap-2">
                                            <input 
                                                type="date"
                                                value={newTaskDueDate}
                                                onChange={(e) => setNewTaskDueDate(e.target.value)}
                                                placeholder={t('dueDate')}
                                                className={`px-2 py-1 text-xs rounded outline-none ${themeClasses.input}`}
                                            />
                                            <input 
                                                type="datetime-local"
                                                value={newTaskReminder}
                                                onChange={(e) => setNewTaskReminder(e.target.value)}
                                                placeholder={t('taskReminder')}
                                                className={`px-2 py-1 text-xs rounded outline-none ${themeClasses.input}`}
                                            />
                                        </div>
                                        <select 
                                            value={newTaskResponsible}
                                            onChange={(e) => setNewTaskResponsible(e.target.value)}
                                            className={`w-full px-2 py-1 text-xs rounded outline-none ${themeClasses.select}`}
                                        >
                                            <option value="">{t('unassigned')}</option>
                                            {(event.participants || []).map((p, idx) => (
                                                <option key={p.userId || idx} value={p.userName || p.email}>
                                                    {p.userName || p.email}
                                                </option>
                                            ))}
                                        </select>
                                        <div className="flex gap-2">
                                            <select 
                                                value={newTaskStatus}
                                                onChange={(e) => setNewTaskStatus(e.target.value)}
                                                className={`flex-1 px-2 py-1 text-xs rounded outline-none ${themeClasses.select}`}
                                            >
                                                <option value="open">{t('statusOpen')}</option>
                                                <option value="inProgress">{t('statusInProgress')}</option>
                                                <option value="completed">{t('statusCompleted')}</option>
                                            </select>
                                            <select 
                                                value={newTaskPriority}
                                                onChange={(e) => setNewTaskPriority(e.target.value)}
                                                className={`flex-1 px-2 py-1 text-xs rounded outline-none ${themeClasses.select}`}
                                            >
                                                <option value="high">{t('priorityHigh')}</option>
                                                <option value="normal">{t('priorityNormal')}</option>
                                                <option value="low">{t('priorityLow')}</option>
                                            </select>
                                        </div>
                                        <button 
                                            onClick={addTask}
                                            className={`w-full py-2 rounded-lg font-bold text-sm ${themeClasses.button}`}
                                        >
                                            <Plus size={16} className="inline mr-1" /> {t('addTask')}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const EventModal = ({ show, onClose, onSave, selectedDate, themeClasses, isComic, user, viewingFriendId, viewingFriendName, currentUserName }) => {
            if (!show) return null;
            const [formData, setFormData] = useState({ title: '', date: formatDate(selectedDate), time: '12:00', category: 'personal', repeat: 'none', location: '', timezone: 'Europe/Berlin' });
            const defaultMode = viewingFriendId ? 'request' : 'self';
            const [createMode, setCreateMode] = useState(defaultMode);
            const [invitees, setInvitees] = useState([]);
            const [friends, setFriends] = useState([]);
            
            // Fetch friends list for invitations
            useEffect(() => {
                if (!user || !show) return;
                const unsub = onSnapshot(collection(db, 'artifacts', appId, 'users', user.uid, 'friends'), (snap) => {
                    const fris = [];
                    snap.forEach(doc => {
                        const d = doc.data();
                        if (d.status === 'accepted') fris.push({ id: doc.id, ...d });
                    });
                    setFriends(fris);
                }, err => console.error("Friends Error", err));
                return () => unsub();
            }, [user, show]);
            
            const addFriendAsInvitee = (friendId, friendName) => {
                if (!invitees.find(inv => inv.userId === friendId)) {
                    setInvitees([...invitees, { userId: friendId, userName: friendName, status: 'pending' }]);
                }
            };
            
            const removeInvitee = (index) => {
                setInvitees(invitees.filter((_, i) => i !== index));
            };
            
            const handleSave = () => {
                onSave({ ...formData, invitees }, createMode);
            };
            
            return (
                <div className="fixed inset-0 z-50 flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm p-4 text-white">
                    <div className={`w-full max-w-md rounded-2xl p-6 max-h-[90vh] overflow-y-auto ${isComic?'bg-[#f4e4bc] border-4 border-[#8b5a2b] text-[#4a3b2a]':'bg-slate-900 border border-slate-700'}`}>
                        <h2 className="text-xl font-bold mb-4">{t('newEvent')}</h2>
                        {viewingFriendId && (
                            <div className="mb-3 p-3 rounded-xl border border-slate-700/60 bg-black/20">
                                <div className="text-xs font-bold opacity-80 mb-2">Erstellen</div>
                                <div className="space-y-2">
                                    <label className="flex items-center gap-2 text-sm">
                                        <input type="radio" name="createMode" checked={createMode==='self'} onChange={()=>setCreateMode('self')} />
                                        <span>Nur f√ºr mich</span>
                                    </label>
                                    <label className="flex items-center gap-2 text-sm">
                                        <input type="radio" name="createMode" checked={createMode==='request'} onChange={()=>setCreateMode('request')} />
                                        <span>Als Anfrage an <span className="font-bold">{viewingFriendName || 'Freund'}</span> (im Freund-Kalender nach Best√§tigung)</span>
                                    </label>
                                    <label className="flex items-center gap-2 text-sm">
                                        <input type="radio" name="createMode" checked={createMode==='self_and_request'} onChange={()=>setCreateMode('self_and_request')} />
                                        <span>F√ºr mich + Anfrage an <span className="font-bold">{viewingFriendName || 'Freund'}</span></span>
                                    </label>
                                </div>
                            </div>
                        )}
                        <div className="space-y-4">
                            <div>
                                <label className="text-xs opacity-70 block mb-1 font-bold">{t('category')}</label>
                                <div className="grid grid-cols-5 gap-2">{CATEGORIES.map(cat => <button key={cat.id} onClick={() => setFormData({...formData, category: cat.id})} className={`p-2 rounded-lg flex flex-col items-center gap-1 transition-all ${formData.category === cat.id ? 'bg-blue-600/30 border border-blue-500' : 'opacity-60'}`}><span className="text-xl">{cat.icon}</span><span className="text-[9px]">{t(cat.id)}</span></button>)}</div>
                            </div>
                            <input value={formData.title} onChange={e => setFormData({...formData, title: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`} placeholder={t('title')}/>
                            <div className="grid grid-cols-2 gap-2"><input type="date" value={formData.date} onChange={e => setFormData({...formData, date: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`}/><input type="time" value={formData.time} onChange={e => setFormData({...formData, time: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`}/></div>
                            <div>
                                <label className="text-xs opacity-70 block mb-1 font-bold">{t('repeat')}</label>
                                <select value={formData.repeat || 'none'} onChange={e => setFormData({...formData, repeat: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}>
                                    <option value="none">{t('repeatNone')}</option>
                                    <option value="daily">{t('repeatDaily')}</option>
                                    <option value="weekly">{t('repeatWeekly')}</option>
                                    <option value="monthly">{t('repeatMonthly')}</option>
                                    <option value="yearly">{t('repeatYearly')}</option>
                                </select>
                            </div>
                            <input value={formData.location || ''} onChange={e => setFormData({...formData, location: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`} placeholder={t('location')}/>
                            <div>
                                <label className="text-xs opacity-70 block mb-1 font-bold">{t('timezone')}</label>
                                <select value={formData.timezone || 'Europe/Berlin'} onChange={e => setFormData({...formData, timezone: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}>
                                    {TIMEZONES.map(tz => <option key={tz} value={tz}>{tz}</option>)}
                                </select>
                            </div>
                            
                            {/* Invitees Section */}
                            {!viewingFriendId && (
                                <div className="pt-4 border-t border-slate-700/50">
                                    <label className="text-xs opacity-70 block mb-3 font-bold uppercase">{t('inviteParticipants')}</label>
                                    
                                    {/* Friends quick-add */}
                                    {friends.length > 0 && (
                                        <div className="mb-3">
                                            <div className="text-xs opacity-60 mb-2">{t('myFriends')}</div>
                                            <div className="flex flex-wrap gap-2">
                                                {friends.map(friend => (
                                                    <button
                                                        key={friend.id}
                                                        type="button"
                                                        onClick={() => addFriendAsInvitee(friend.id, friend.name || friend.shareCode)}
                                                        disabled={invitees.find(inv => inv.userId === friend.id)}
                                                        className={`text-xs px-2 py-1 rounded ${invitees.find(inv => inv.userId === friend.id) ? 'bg-blue-500/50 opacity-50 cursor-not-allowed' : 'bg-blue-500/20 text-blue-400 hover:bg-blue-500/30'}`}
                                                    >
                                                        + {friend.name || friend.shareCode}
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                    
                                    {/* Invitees list */}
                                    {invitees.length > 0 && (
                                        <div className="space-y-2">
                                            {invitees.map((inv, idx) => (
                                                <div key={inv.userId || inv.email || `inv-${idx}`} className={`flex items-center justify-between p-2 rounded-lg ${isComic ? 'bg-[#fdf6e3]' : 'bg-black/20'}`}>
                                                    <div className="flex items-center gap-2 flex-1">
                                                        <div className="w-6 h-6 rounded-full bg-blue-500 flex items-center justify-center text-white text-xs">
                                                            {(inv.userName || inv.name || inv.email || 'U').charAt(0).toUpperCase()}
                                                        </div>
                                                        <div className="flex flex-col">
                                                            <span className="text-xs font-semibold">{inv.userName || inv.name || inv.email}</span>
                                                            {inv.email && (inv.userName || inv.name) && <span className="text-[10px] opacity-60">{inv.email}</span>}
                                                        </div>
                                                    </div>
                                                    <button
                                                        type="button"
                                                        onClick={() => removeInvitee(idx)}
                                                        className="text-red-400 p-1"
                                                    >
                                                        <X size={14}/>
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            )}

                            <div className="flex gap-3 mt-4"><button onClick={onClose} className="flex-1 py-3 rounded-xl font-bold opacity-70 bg-slate-800">{t('cancel')}</button><button onClick={handleSave} className={`flex-1 py-3 rounded-xl font-bold ${themeClasses.button}`}>{t('save')}</button></div>
                        </div>
                    </div>
                </div>
            );
        };

        const DayOptionsModal = ({ show, onClose, onAssignShift, onCreateEvent, onClearShift, selectedDate, shifts, themeClasses, isComic, viewingFriend }) => {
            if (!show) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm p-4 text-white">
                    <div className={`w-full max-w-md rounded-2xl p-6 ${isComic?'bg-[#f4e4bc] border-4 border-[#8b5a2b] text-[#4a3b2a]':'bg-slate-900 border border-slate-700'}`}>
                        <div className="flex justify-between items-center mb-6"><h2 className="text-xl font-bold">{t('dayOptions')}</h2><button onClick={onClose}><X /></button></div>
                        <div className="space-y-4">
                            {!viewingFriend && (
                                <>
                                    <div className="grid grid-cols-2 gap-2">{shifts.map(s => <button key={s.id} onClick={() => { onAssignShift(formatDate(selectedDate), s.id); onClose(); }} className="p-3 rounded-lg flex items-center justify-center gap-2 font-bold text-sm" style={{ backgroundColor: s.color + '40', border: `1px solid ${s.color}`, color: isComic?'#4a3b2a':'white' }}><div className="w-3 h-3 rounded-full" style={{ backgroundColor: s.color }}></div> {s.name}</button>)}</div>
                                    <button onClick={() => { onClearShift(formatDate(selectedDate)); onClose(); }} className="w-full py-3 bg-red-500/10 text-red-400 border border-red-500/30 rounded-xl font-bold flex items-center justify-center gap-2"><Trash2 size={18}/> {t('clearShift')}</button>
                                </>
                            )}
                            <button onClick={() => { onClose(); onCreateEvent(); }} className={`w-full py-4 rounded-xl font-bold flex items-center justify-center gap-2 ${themeClasses.button}`}><Plus size={20}/> {t('createEvent')}</button>
                        </div>
                    </div>
                </div>
            )
        };



        const WeatherLocationModal = ({ show, onClose, currentPref, onSave }) => {
            const [mode, setMode] = useState(currentPref?.mode || "geo"); // geo | manual
            const [queryText, setQueryText] = useState("");
            const [results, setResults] = useState([]);
            const [loading, setLoading] = useState(false);
            const [err, setErr] = useState("");

            useEffect(() => {
                if (!show) return;
                setMode(currentPref?.mode || "geo");
                setResults([]);
                setErr("");
                setQueryText(currentPref?.manual?.label || "");
            }, [show]);

            const doSearch = async () => {
                const q = (queryText || "").trim();
                if (!q) return;
                if (!navigator.onLine) { setErr("Offline ‚Äì Suche nicht verf√ºgbar."); return; }
                setErr("");
                setLoading(true);
                try {
                    const res = await fetch(buildGeocodeUrl(q));
                    if (!res.ok) throw new Error("HTTP " + res.status);
                    const data = await res.json();
                    const list = (data?.results || []).map(r => ({
                        label: [r.name, r.admin1, r.country].filter(Boolean).join(", "),
                        lat: r.latitude,
                        lon: r.longitude
                    }));
                    setResults(list);
                    if (list.length === 0) setErr("Keine Treffer gefunden.");
                } catch (e) {
                    console.error(e);
                    setErr("Suche aktuell nicht verf√ºgbar.");
                } finally {
                    setLoading(false);
                }
            };

            const choose = (place) => {
                onSave({ mode: "manual", manual: place });
            };

            const saveGeo = () => {
                onSave({ mode: "geo", manual: currentPref?.manual || null });
            };

            if (!show) return null;
            return (
                <div className="fixed inset-0 z-[90] flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm p-4 text-white">
                    <div className="w-full max-w-md rounded-2xl p-6 bg-slate-900 border border-slate-700">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-lg font-bold">Wetter-Ort ausw√§hlen</h2>
                            <button onClick={onClose}><X /></button>
                        </div>

                        <div className="grid grid-cols-2 gap-2 mb-4">
                            <button
                                onClick={() => setMode("geo")}
                                className={`p-3 rounded-xl font-bold border ${mode === "geo" ? "bg-blue-600/20 border-blue-500/30 text-blue-200" : "bg-white/5 border-slate-700 text-slate-200"}`}
                            >
                                Standort automatisch
                            </button>
                            <button
                                onClick={() => setMode("manual")}
                                className={`p-3 rounded-xl font-bold border ${mode === "manual" ? "bg-blue-600/20 border-blue-500/30 text-blue-200" : "bg-white/5 border-slate-700 text-slate-200"}`}
                            >
                                Manuell
                            </button>
                        </div>

                        {mode === "geo" ? (
                            <div className="rounded-xl border border-slate-700 bg-slate-950 p-4">
                                <div className="text-sm font-bold mb-1">Automatischer Standort</div>
                                <div className="text-xs text-slate-400 mb-3">
                                    Nutzt GPS/Browser-Standort. Falls blockiert: Fallback Z√ºrich.
                                </div>
                                <button onClick={saveGeo} className="w-full py-3 rounded-xl bg-blue-600 hover:bg-blue-700 text-white font-bold">
                                    Speichern
                                </button>
                            </div>
                        ) : (
                            <div className="rounded-xl border border-slate-700 bg-slate-950 p-4">
                                <div className="text-sm font-bold mb-1">Manueller Ort</div>
                                <div className="text-xs text-slate-400 mb-3">
                                    Suche nach Stadt/Region und w√§hle einen Treffer.
                                </div>

                                <div className="flex gap-2">
                                    <input
                                        value={queryText}
                                        onChange={(e) => setQueryText(e.target.value)}
                                        placeholder="z. B. Z√ºrich, Basel, Milano ‚Ä¶"
                                        className="flex-1 p-3 rounded-xl bg-slate-900 border border-slate-700 text-white outline-none focus:border-blue-500"
                                    />
                                    <button onClick={doSearch} className="px-4 rounded-xl bg-white/5 hover:bg-white/10 border border-slate-700 font-bold text-sm">
                                        {loading ? "‚Ä¶" : "Suche"}
                                    </button>
                                </div>

                                {err && <div className="mt-3 text-xs text-red-300 bg-red-500/10 border border-red-500/20 p-2 rounded-lg">{err}</div>}

                                <div className="mt-3 space-y-2 max-h-56 overflow-y-auto">
                                    {results.map((r, idx) => (
                                        <button key={idx} onClick={() => choose(r)} className="w-full text-left p-3 rounded-xl bg-white/5 hover:bg-white/10 border border-slate-700">
                                            <div className="font-bold">{r.label}</div>
                                            <div className="text-xs text-slate-400">Lat {r.lat.toFixed(4)} ¬∑ Lon {r.lon.toFixed(4)}</div>
                                        </button>
                                    ))}
                                </div>

                                {currentPref?.manual?.label && (
                                    <div className="mt-4 text-xs text-slate-400">
                                        Aktuell gespeichert: <span className="text-slate-200 font-bold">{currentPref.manual.label}</span>
                                    </div>
                                )}
                            </div>
                        )}

                        <div className="mt-4 text-[11px] text-slate-500">
                            Tipp: F√ºr konsistente Ergebnisse (ohne Standortfreigabe) Manuell verwenden.
                        </div>
                    </div>
                </div>
            );
        };

        // --- 7-DAY WEATHER FORECAST MODAL ---
        const WeatherForecastModal = ({ show, onClose, forecastData, weatherLocation }) => {
            if (!show || !forecastData) return null;

            const formatDateShort = (dateStr) => {
                const d = new Date(dateStr);
                const days = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
                const months = ['Jan', 'Feb', 'M√§r', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
                return `${days[d.getDay()]}, ${d.getDate()}. ${months[d.getMonth()]}`;
            };

            return (
                <div className="fixed inset-0 z-[90] flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm p-4 text-white">
                    <div className="w-full max-w-2xl rounded-2xl p-6 bg-slate-900 border border-slate-700 max-h-[90vh] overflow-y-auto">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-lg font-bold">7-Tage-Wettervorhersage</h2>
                            <button onClick={onClose}><X /></button>
                        </div>

                        {weatherLocation && (
                            <div className="text-sm text-slate-400 mb-4">
                                üìç {weatherLocation}
                            </div>
                        )}

                        <div className="space-y-3">
                            {forecastData.time?.slice(0, 7).map((dateStr, idx) => (
                                <div key={dateStr} className="p-4 rounded-xl bg-slate-950 border border-slate-700 flex items-center justify-between gap-4">
                                    <div className="flex items-center gap-4 min-w-0 flex-1">
                                        <div className="text-3xl">
                                            {getWeatherMeta(forecastData.weather_code[idx]).icon}
                                        </div>
                                        <div className="min-w-0 flex-1">
                                            <div className="font-bold text-sm">{formatDateShort(dateStr)}</div>
                                            <div className="text-xs text-slate-400">{getWeatherMeta(forecastData.weather_code[idx]).label}</div>
                                        </div>
                                    </div>
                                    
                                    <div className="grid grid-cols-3 gap-3 text-center shrink-0">
                                        <div>
                                            <div className="text-xs text-slate-400">Max</div>
                                            <div className="font-bold text-orange-400">{Math.round(forecastData.temperature_2m_max[idx])}¬∞</div>
                                        </div>
                                        <div>
                                            <div className="text-xs text-slate-400">Min</div>
                                            <div className="font-bold text-blue-400">{Math.round(forecastData.temperature_2m_min[idx])}¬∞</div>
                                        </div>
                                        <div>
                                            <div className="text-xs text-slate-400">üíß</div>
                                            <div className="font-bold text-sky-400">{Math.round(forecastData.precipitation_sum[idx])}mm</div>
                                        </div>
                                    </div>
                                    
                                    <div className="text-right shrink-0">
                                        <div className="text-xs text-slate-400">Wind</div>
                                        <div className="font-bold text-sm">{Math.round(forecastData.wind_speed_10m_max[idx])} km/h</div>
                                    </div>
                                </div>
                            ))}
                        </div>

                        <div className="mt-4 text-[11px] text-slate-500 text-center">
                            Datenquelle: Open-Meteo API
                        </div>
                    </div>
                </div>
            );
        };

        // --- PREMIUM GATE MODAL FOR SECRET NACHRICHTEN ---
        const PremiumGateModal = ({ show, onClose, onUnlock }) => {
            const [codeInput, setCodeInput] = useState('');
            const [error, setError] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                if (codeInput.trim() === 'Happymeal94') {
                    try {
                        localStorage.setItem('timeroster_secret_premium_unlocked', 'true');
                    } catch (e) {
                        console.error('Failed to save unlock state', e);
                    }
                    onUnlock();
                    onClose();
                    setCodeInput('');
                    setError('');
                } else {
                    setError('Falscher Code. Bitte versuche es erneut.');
                }
            };

            if (!show) return null;

            return (
                <div className="fixed inset-0 z-[90] flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm p-4 text-white">
                    <div className="w-full max-w-md rounded-2xl p-6 bg-slate-900 border border-slate-700">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-lg font-bold">üîí Premium Freischalten</h2>
                            <button onClick={onClose}><X /></button>
                        </div>

                        <div className="mb-6">
                            <div className="text-sm mb-4">
                                Der Zugriff auf Premium.
                            </div>
                            <div className="p-4 rounded-xl bg-gradient-to-br from-amber-500/20 to-orange-500/20 border border-amber-500/30">
                                <div className="font-bold mb-2 text-amber-300">‚ú® Premium Features:</div>
                                <ul className="text-sm space-y-1 text-amber-100">
                                    <li>‚Ä¢ 1</li>
                                    <li>‚Ä¢ 2</li>
                                    <li>‚Ä¢ 3</li>
                                    <li>‚Ä¢ 4</li>
                                </ul>
                            </div>
                        </div>

                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div>
                                <label className="block text-sm font-bold mb-2">Code-Wort eingeben:</label>
                                <input
                                    type="text"
                                    value={codeInput}
                                    onChange={(e) => { setCodeInput(e.target.value); setError(''); }}
                                    placeholder="Code-Wort hier eingeben"
                                    className="w-full p-3 rounded-xl bg-slate-950 border border-slate-700 text-white outline-none focus:border-blue-500"
                                    autoFocus
                                />
                            </div>

                            {error && (
                                <div className="text-sm text-red-300 bg-red-500/10 border border-red-500/20 p-3 rounded-lg">
                                    {error}
                                </div>
                            )}

                            <button
                                type="submit"
                                className="w-full py-3 rounded-xl bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700 text-white font-bold"
                            >
                                Freischalten
                            </button>
                        </form>

                        <div className="mt-4 text-xs text-slate-500 text-center">
                            Hinweis: Der Code wird nur einmal ben√∂tigt.
                        </div>
                    </div>
                </div>
            );
        };

        // --- CALENDAR MANAGEMENT MODALS ---
        
        const CalendarManagerModal = ({ show, onClose, calendars, createCalendar, themeClasses, currentUserId }) => {
            const [name, setName] = useState('');
            const [description, setDescription] = useState('');
            const [color, setColor] = useState('#3B82F6');
            
            if (!show) return null;
            
            const handleCreate = async () => {
                if (!name.trim()) {
                    alert(t('pleaseEnterName'));
                    return;
                }
                
                await createCalendar({ name, description, color });
                setName('');
                setDescription('');
                setColor('#3B82F6');
                onClose();
            };
            
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70">
                    <div className={`w-full max-w-lg rounded-2xl p-6 ${themeClasses.card}`}>
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-bold">{t('manageCalendars')}</h2>
                            <button onClick={onClose} className="p-2 rounded-lg hover:bg-white/5">
                                <X size={20}/>
                            </button>
                        </div>
                        
                        <div className="space-y-4 mb-6">
                            <div>
                                <label className="block text-sm font-bold mb-2">Neuer Kalender</label>
                                <input 
                                    type="text" 
                                    value={name}
                                    onChange={(e) => setName(e.target.value)}
                                    placeholder="Kalendername"
                                    className={`w-full p-3 rounded-lg ${themeClasses.input}`}
                                />
                            </div>
                            
                            <div>
                                <input 
                                    type="text" 
                                    value={description}
                                    onChange={(e) => setDescription(e.target.value)}
                                    placeholder="Beschreibung (optional)"
                                    className={`w-full p-3 rounded-lg ${themeClasses.input}`}
                                />
                            </div>
                            
                            <div>
                                <label className="block text-sm font-bold mb-2">Farbe</label>
                                <div className="flex gap-2">
                                    {['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', '#EC4899'].map(c => (
                                        <button
                                            key={c}
                                            onClick={() => setColor(c)}
                                            className={`w-10 h-10 rounded-full border-2 ${color === c ? 'border-white scale-110' : 'border-transparent'}`}
                                            style={{ backgroundColor: c }}
                                        />
                                    ))}
                                </div>
                            </div>
                            
                            <button 
                                onClick={handleCreate}
                                className={`w-full py-3 rounded-lg font-bold ${themeClasses.button}`}
                            >
                                <FolderPlus className="inline mr-2" size={18}/>
                                Kalender erstellen
                            </button>
                        </div>
                        
                        <div>
                            <h3 className="text-sm font-bold mb-3 opacity-70">{t('myCalendars')}</h3>
                            <div className="space-y-2">
                                {calendars.map(cal => (
                                    <div key={cal.id} className="flex items-center gap-3 p-3 rounded-lg bg-black/20">
                                        <div 
                                            className="w-4 h-4 rounded-full" 
                                            style={{ backgroundColor: cal.color }}
                                        />
                                        <div className="flex-1">
                                            <div className="font-bold">{cal.name}</div>
                                            {cal.description && <div className="text-xs opacity-60">{cal.description}</div>}
                                        </div>
                                        <div className="text-xs opacity-60">
                                            {cal.ownerId === currentUserId ? t('calendarOwner') : (cal.roles && cal.roles[currentUserId] || t('calendarMember'))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };
        
        const CalendarSettingsModal = ({ show, onClose, calendar, makePublic, getPublicLink, getSubscriptionLink, updateCalendar, themeClasses }) => {
            const [showCopySuccess, setShowCopySuccess] = useState(false);
            
            if (!show || !calendar) return null;
            
            const copyToClipboard = (text) => {
                navigator.clipboard.writeText(text).then(() => {
                    setShowCopySuccess(true);
                    setTimeout(() => setShowCopySuccess(false), 2000);
                });
            };
            
            const publicLink = getPublicLink(calendar.id);
            const subscriptionLink = getSubscriptionLink(calendar.id);
            
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70">
                    <div className={`w-full max-w-lg rounded-2xl p-6 ${themeClasses.card}`}>
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-bold">{t('shareCalendar')}</h2>
                            <button onClick={onClose} className="p-2 rounded-lg hover:bg-white/5">
                                <X size={20}/>
                            </button>
                        </div>
                        
                        <div className="mb-4">
                            <div className="flex items-center gap-3 p-3 rounded-lg bg-black/20">
                                <div 
                                    className="w-4 h-4 rounded-full" 
                                    style={{ backgroundColor: calendar.color }}
                                />
                                <div>
                                    <div className="font-bold">{calendar.name}</div>
                                    {calendar.description && <div className="text-xs opacity-60">{calendar.description}</div>}
                                </div>
                            </div>
                        </div>
                        
                        <div className="space-y-4">
                            <div className="flex items-center justify-between p-3 rounded-lg bg-black/10">
                                <div>
                                    <div className="font-bold">√ñffentlich teilen</div>
                                    <div className="text-xs opacity-60">Jeder mit dem Link kann den Kalender ansehen</div>
                                </div>
                                <button 
                                    onClick={() => makePublic(calendar.id, !calendar.isPublic)}
                                    className={`px-4 py-2 rounded-lg font-bold ${calendar.isPublic ? 'bg-green-600' : 'bg-gray-600'}`}
                                >
                                    {calendar.isPublic ? 'EIN' : 'AUS'}
                                </button>
                            </div>
                            
                            {calendar.isPublic && (
                                <>
                                    <div>
                                        <label className="block text-sm font-bold mb-2">√ñffentlicher Link</label>
                                        <div className="flex gap-2">
                                            <input 
                                                type="text" 
                                                value={publicLink || ''}
                                                readOnly
                                                className={`flex-1 p-3 rounded-lg ${themeClasses.input}`}
                                            />
                                            <button 
                                                onClick={() => copyToClipboard(publicLink)}
                                                className={`px-4 py-3 rounded-lg ${themeClasses.button}`}
                                                title="Link kopieren"
                                            >
                                                {showCopySuccess ? <Check size={18}/> : <Copy size={18}/>}
                                            </button>
                                        </div>
                                        <div className="text-xs opacity-60 mt-1">
                                            <Globe className="inline mr-1" size={12}/>
                                            Schreibgesch√ºtzter Zugriff f√ºr alle
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <label className="block text-sm font-bold mb-2">Abonnement-Link (ICS)</label>
                                        <div className="flex gap-2">
                                            <input 
                                                type="text" 
                                                value={subscriptionLink || ''}
                                                readOnly
                                                className={`flex-1 p-3 rounded-lg ${themeClasses.input}`}
                                            />
                                            <button 
                                                onClick={() => copyToClipboard(subscriptionLink)}
                                                className={`px-4 py-3 rounded-lg ${themeClasses.button}`}
                                                title="Link kopieren"
                                            >
                                                {showCopySuccess ? <Check size={18}/> : <Copy size={18}/>}
                                            </button>
                                        </div>
                                        <div className="text-xs opacity-60 mt-1">
                                            <Link2 className="inline mr-1" size={12}/>
                                            F√ºr Google Calendar, Apple Calendar, Outlook
                                        </div>
                                    </div>
                                </>
                            )}
                            
                            <div className="text-xs opacity-60 p-3 rounded-lg bg-blue-500/10 border border-blue-500/20">
                                <AlertCircle className="inline mr-1" size={14}/>
                                Der Abonnement-Link erm√∂glicht automatische Synchronisation in anderen Kalender-Apps.
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- MAIN APP ---
        function TimeRosterApp() {
            const [user, setUser] = useState(null);
            const [authChecked, setAuthChecked] = useState(false);
            const [view, setView] = useState('auth'); 
            const [events, setEvents] = useState([]);
            const [shifts, setShifts] = useState(DEFAULT_SHIFTS);
            const [schedule, setSchedule] = useState({});
            const [shareCode, setShareCode] = useState('');
            const [displayName, setDisplayName] = useState('');
            const [uiError, setUiError] = useState('');
            
            // Weather (dashboard)
            const [weather, setWeather] = useState(null); // { temperature, wind, code, time, lat, lon }
            const [weatherLocation, setWeatherLocation] = useState('');
            const [weatherLoading, setWeatherLoading] = useState(false);
            const [weatherError, setWeatherError] = useState('');

            const [weatherPref, setWeatherPref] = useState({ mode: "geo", manual: null });
            const [showWeatherSettings, setShowWeatherSettings] = useState(false);
            const [showWeatherForecast, setShowWeatherForecast] = useState(false);
            const [forecastData, setForecastData] = useState(null);
            const [forecastLoading, setForecastLoading] = useState(false);

            const todayStr = formatDate(new Date());
            const dailyQuote = useMemo(() => getDailyQuote(todayStr, user?.uid || "anon"), [todayStr, user?.uid]);

            // Upcoming events filter (Dashboard)
            const [upcomingRange, setUpcomingRange] = useState('week'); // week | month | year

            const upcomingWindowEnd = useMemo(() => {
                const base = new Date();
                base.setHours(0,0,0,0);
                const end = new Date(base);
                if (upcomingRange === 'month') end.setMonth(end.getMonth() + 1);
                else if (upcomingRange === 'year') end.setFullYear(end.getFullYear() + 1);
                else end.setDate(end.getDate() + 7);
                return end;
            }, [upcomingRange]);

            const upcomingItems = useMemo(() => {
                const start = new Date();
                start.setHours(0,0,0,0);
                const end = new Date(upcomingWindowEnd);
                const items = [];
                for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                    const dateStr = formatDate(d);
                    const dayList = getEventsForDate(dateStr, events);
                    for (const ev of dayList) {
                        items.push({
                            ...ev,
                            _occDate: dateStr,
                            _key: `${ev.id || 'ev'}_${dateStr}`
                        });
                    }
                }
                // Sort by occurrence date + time
                items.sort((a,b) => (a._occDate + ' ' + (a.time||'')).localeCompare(b._occDate + ' ' + (b.time||'')));
                // Keep it pragmatic: show max 50
                return items.slice(0, 50);
            }, [events, upcomingWindowEnd]);




            const [theme, setTheme] = useState('noble');
            const [currentFont, setCurrentFont] = useState('font-inter');
            const [fontScale, setFontScale] = useState(1);
            const [lang, setLang] = useState('de');
            
            // UI preferences persistence (per user)
            useEffect(() => {
                if (!user) return;
                try {
                    const raw = localStorage.getItem(getUiPrefKey(user.uid));
                    if (!raw) return;
                    const pref = JSON.parse(raw);
                    if (pref?.theme) setTheme(pref.theme);
                    if (pref?.currentFont) setCurrentFont(pref.currentFont);
                    if (typeof pref?.fontScale === "number") setFontScale(pref.fontScale);
                    if (pref?.lang) setLang(pref.lang);
                    if (pref?.calendarViewMode) setCalendarViewMode(pref.calendarViewMode);
                } catch (e) { /* ignore */ }
            }, [user?.uid]);

            useEffect(() => {
                if (!user) return;
                try {
                    localStorage.setItem(getUiPrefKey(user.uid), JSON.stringify({ theme, currentFont, fontScale, lang, calendarViewMode }));
                } catch (e) { /* ignore */ }
            }, [user?.uid, theme, currentFont, fontScale, lang, calendarViewMode]);


            const [showSecret, setShowSecret] = useState(false);
            const [secretPremiumUnlocked, setSecretPremiumUnlocked] = useState(() => {
                try {
                    return localStorage.getItem('timeroster_secret_premium_unlocked') === 'true';
                } catch (e) {
                    return false;
                }
            });
            const [showPremiumGate, setShowPremiumGate] = useState(false);
            const [selectedDate, setSelectedDate] = useState(new Date());
            const [showEventModal, setShowEventModal] = useState(false);
            const [showDayOptions, setShowDayOptions] = useState(false);
            const [selectedEvent, setSelectedEvent] = useState(null);
            const [viewingUserId, setViewingUserId] = useState(null); 
            const [viewingFriendName, setViewingFriendName] = useState(null);
            const [pendingEventRequests, setPendingEventRequests] = useState([]);
            
            // Benachrichtigungen
            const [unreadMessageCount, setUnreadMessageCount] = useState(0);
            const [fcmToken, setFcmToken] = useState(null);
            const [notificationsSupported, setNotificationsSupported] = useState(false);
            
            // Multi-calendar support
            const [calendars, setCalendars] = useState([]); // List of calendars user has access to
            const [activeCalendarId, setActiveCalendarId] = useState(null); // Currently selected calendar
            const [showCalendarManager, setShowCalendarManager] = useState(false);
            const [showCalendarSettings, setShowCalendarSettings] = useState(false);
            const [selectedCalendarForSettings, setSelectedCalendarForSettings] = useState(null);
            
            // Calendar view mode: month | week | day
            const [calendarViewMode, setCalendarViewMode] = useState('month');
            
            // Search state
            const [searchQuery, setSearchQuery] = useState('');
            const [showSearch, setShowSearch] = useState(false);

            // Search results - optimized for performance
            const searchResults = useMemo(() => {
                if (!searchQuery.trim()) return [];
                const query = searchQuery.toLowerCase();
                const results = [];
                const seenKeys = new Set();
                
                // First pass: Search non-recurring events directly
                for (const ev of events) {
                    const titleMatch = ev.title.toLowerCase().includes(query);
                    const dateMatch = ev.date?.includes(query);
                    const categoryMatch = t(ev.category).toLowerCase().includes(query);
                    
                    if (titleMatch || categoryMatch) {
                        // For non-recurring or title/category matches, add all occurrences in range
                        const startDate = new Date();
                        startDate.setFullYear(startDate.getFullYear() - 1);
                        const endDate = new Date();
                        endDate.setFullYear(endDate.getFullYear() + 1); // Reduced to 2 years total
                        
                        for (let d = new Date(startDate); d <= endDate && results.length < 50; d.setDate(d.getDate() + 1)) {
                            const dateStr = formatDate(d);
                            if (matchesRecurrence(ev, dateStr)) {
                                const key = `${ev.id || 'ev'}_${dateStr}`;
                                if (!seenKeys.has(key)) {
                                    seenKeys.add(key);
                                    results.push({
                                        ...ev,
                                        _occDate: dateStr,
                                        _key: key
                                    });
                                }
                            }
                        }
                    } else if (dateMatch && ev.date === query) {
                        // Direct date match
                        const key = `${ev.id || 'ev'}_${ev.date}`;
                        if (!seenKeys.has(key)) {
                            seenKeys.add(key);
                            results.push({
                                ...ev,
                                _occDate: ev.date,
                                _key: key
                            });
                        }
                    }
                    
                    if (results.length >= 50) break;
                }
                
                return results.slice(0, 50);
            }, [searchQuery, events]); 

            useEffect(() => {
                const unsubscribe = onAuthStateChanged(auth, (u) => {
                    setUser(u); setAuthChecked(true); 
                    if(u) {
                        setView('dashboard');
                        // Profile Init
                        const profileRef = doc(db, 'artifacts', appId, 'users', u.uid, 'profile', 'main');
                        getDoc(profileRef).then(async (snap) => {
                            if (snap.exists()) {
                                const data = snap.data() || {};
                                const sc = data.shareCode || generateCode();
                                const nm = (data.name || '').trim() || getUserName(u);
                                setShareCode(sc);
                                setDisplayName(nm);
                                // Ensure public profile exists / stays in sync
                                await setDoc(doc(db, 'artifacts', appId, 'public_profiles', sc), { userId: u.uid, name: nm }, { merge: true });
                                if (!data.shareCode || !data.name) {
                                    await setDoc(profileRef, { shareCode: sc, name: nm }, { merge: true });
                                }
                            } else {
                                const newCode = generateCode();
                                const userName = getUserName(u);
                                setShareCode(newCode);
                                setDisplayName(userName);
                                await setDoc(profileRef, { shareCode: newCode, name: userName });
                                await setDoc(doc(db, 'artifacts', appId, 'public_profiles', newCode), { userId: u.uid, name: userName });
                            }
                        }).catch(e => console.log("Profile init error (silent)", e));
                    } else setView('auth');
                });
                return () => unsubscribe();
            }, []);

            useEffect(() => {
                if(!user) return;
                // Load pending event requests for this user
                const q = query(collection(db, 'artifacts', appId, 'users', user.uid, 'pending_events'), where('status', '==', 'pending'));
                const unsub = onSnapshot(q, (snap) => {
                    setPendingEventRequests(snap.docs.map(d => ({ id: d.id, ...d.data() })));
                }, err => console.error("Pending events error", err));
                return () => unsub();
            }, [user]);
            
            // Initialize Firebase Cloud Messaging for push notifications
            useEffect(() => {
                if (!user) return;
                
                const initializeNotifications = async () => {
                    try {
                        // Check if notifications are supported
                        if (!('Notification' in window) || !('serviceWorker' in navigator)) {
                            console.log('Notifications not supported');
                            return;
                        }
                        
                        setNotificationsSupported(true);
                        
                        // Register service worker
                        const registration = await navigator.serviceWorker.register('/firebase-messaging-sw.js');
                        console.log('Service Worker registered:', registration);
                        
                        // Request notification permission
                        const permission = await Notification.requestPermission();
                        if (permission !== 'granted') {
                            console.log('Notification permission not granted');
                            return;
                        }
                        
                        // Initialize Firebase Messaging
                        const messaging = getMessaging(app);
                        
                        // Get FCM token
                        // NOTE: You need to generate a VAPID key in Firebase Console:
                        // Project Settings > Cloud Messaging > Web Push certificates > Generate key pair
                        // For now, we'll try without it (works in some cases)
                        try {
                            const token = await getToken(messaging, {
                                // vapidKey: 'YOUR_VAPID_KEY_HERE', // Generate in Firebase Console
                                serviceWorkerRegistration: registration
                            });
                            
                            if (token) {
                                console.log('FCM Token:', token);
                                setFcmToken(token);
                                
                                // Store token in user profile
                                const profileRef = doc(db, 'artifacts', appId, 'users', user.uid, 'profile', 'main');
                                await setDoc(profileRef, { fcmToken: token }, { merge: true });
                            }
                        } catch (tokenError) {
                            console.warn('Could not get FCM token (VAPID key may be needed):', tokenError);
                        }
                        
                        // Handle foreground messages
                        onMessage(messaging, (payload) => {
                            console.log('Foreground message received:', payload);
                            // Show notification even in foreground
                            if (payload.notification) {
                                new Notification(payload.notification.title || 'Neue Nachricht', {
                                    body: payload.notification.body,
                                    icon: '/icon-192.png'
                                });
                            }
                        });
                        
                    } catch (error) {
                        console.error('Error initializing notifications:', error);
                    }
                };
                
                initializeNotifications();
            }, [user]);
            
            // Track unread messages across all conversations
            useEffect(() => {
                if (!user) return;
                
                const unreadCounts = {}; // Track unread per conversation/group
                const unsubscribers = []; // Collect all listeners for cleanup
                
                const updateTotalUnread = () => {
                    const total = Object.values(unreadCounts).reduce((sum, count) => sum + count, 0);
                    setUnreadMessageCount(total);
                };
                
                const trackUnreadMessages = async () => {
                    try {
                        // Get all accepted friends
                        const friendsQuery = query(
                            collection(db, 'artifacts', appId, 'users', user.uid, 'friends'),
                            where('status', '==', 'accepted')
                        );
                        const friendsSnap = await getDocs(friendsQuery);
                        
                        // Track unread messages for each friend conversation
                        for (const friendDoc of friendsSnap.docs) {
                            const friendData = friendDoc.data();
                            const friendId = friendData.friendId;
                            const chatId = [user.uid, friendId].sort().join('_');
                            
                            const messagesQuery = query(
                                collection(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs'),
                                orderBy('ts', 'desc'),
                                limit(50)
                            );
                            
                            const unsub = onSnapshot(messagesQuery, (snap) => {
                                let unreadCount = 0;
                                snap.docs.forEach(msgDoc => {
                                    const msgData = msgDoc.data();
                                    // Count messages not from current user and not read by current user
                                    if (msgData.from !== user.uid && (!msgData.readBy || !msgData.readBy.includes(user.uid))) {
                                        unreadCount++;
                                    }
                                });
                                
                                unreadCounts[chatId] = unreadCount;
                                updateTotalUnread();
                            });
                            
                            unsubscribers.push(unsub);
                        }
                        
                        // Track unread messages for group conversations
                        const groupsQuery = query(
                            collection(db, 'artifacts', appId, 'secret_groups'),
                            where('members', 'array-contains', user.uid)
                        );
                        const groupsSnap = await getDocs(groupsQuery);
                        
                        for (const groupDoc of groupsSnap.docs) {
                            const groupId = groupDoc.id;
                            
                            const messagesQuery = query(
                                collection(db, 'artifacts', appId, 'secret_groups', groupId, 'msgs'),
                                orderBy('ts', 'desc'),
                                limit(50)
                            );
                            
                            const unsub = onSnapshot(messagesQuery, (snap) => {
                                let unreadCount = 0;
                                snap.docs.forEach(msgDoc => {
                                    const msgData = msgDoc.data();
                                    if (msgData.from !== user.uid && (!msgData.readBy || !msgData.readBy.includes(user.uid))) {
                                        unreadCount++;
                                    }
                                });
                                
                                unreadCounts[`group_${groupId}`] = unreadCount;
                                updateTotalUnread();
                            });
                            
                            unsubscribers.push(unsub);
                        }
                        
                    } catch (error) {
                        console.error('Error tracking unread messages:', error);
                    }
                };
                
                trackUnreadMessages();
                
                // Cleanup: Unsubscribe all listeners when user changes or component unmounts
                // This prevents memory leaks and duplicate listeners
                return () => {
                    unsubscribers.forEach(unsub => unsub());
                };
            }, [user]);
            
            // Load user's calendars
            useEffect(() => {
                if (!user) return;
                
                const initializeCalendars = async () => {
                    try {
                        // Check if user has calendars collection
                        const calendarsRef = collection(db, 'artifacts', appId, 'calendars');
                        const userCalendarsQuery = query(
                            calendarsRef, 
                            where('members', 'array-contains', user.uid)
                        );
                        
                        const snapshot = await getDocs(userCalendarsQuery);
                        
                        if (snapshot.empty) {
                            // Create default calendar for user
                            const defaultCalendarId = generateCalendarId();
                            const defaultCalendar = {
                                id: defaultCalendarId,
                                name: 'Mein Kalender',
                                description: 'Standard Kalender',
                                color: '#3B82F6',
                                ownerId: user.uid,
                                members: [user.uid],
                                roles: {
                                    [user.uid]: 'owner'
                                },
                                isPublic: false,
                                publicToken: null,
                                subscriptionToken: null,
                                createdAt: serverTimestamp(),
                                updatedAt: serverTimestamp()
                            };
                            
                            await setDoc(doc(calendarsRef, defaultCalendarId), defaultCalendar);
                            setCalendars([{ id: defaultCalendarId, ...defaultCalendar }]);
                            setActiveCalendarId(defaultCalendarId);
                            
                            // Migrate existing events to default calendar if any exist
                            const existingEventsSnap = await getDocs(
                                collection(db, 'artifacts', appId, 'users', user.uid, 'events')
                            );
                            
                            if (!existingEventsSnap.empty) {
                                const batch = writeBatch(db);
                                existingEventsSnap.forEach(eventDoc => {
                                    const newEventRef = doc(
                                        collection(db, 'artifacts', appId, 'calendars', defaultCalendarId, 'events')
                                    );
                                    batch.set(newEventRef, eventDoc.data());
                                });
                                await batch.commit();
                                console.log('Migrated existing events to default calendar');
                            }
                        } else {
                            const cals = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                            setCalendars(cals);
                            
                            // Set active calendar to first owned calendar or first calendar
                            const ownedCal = cals.find(c => c.ownerId === user.uid);
                            setActiveCalendarId(ownedCal ? ownedCal.id : cals[0].id);
                        }
                    } catch (error) {
                        console.error('Error initializing calendars:', error);
                    }
                };
                
                initializeCalendars();
            }, [user]);

            useEffect(() => {
                if(!user) return;
                setUiError(''); // Clear previous errors
                
                // Use activeCalendarId for new calendar structure, or fall back to viewing friend's events
                const targetUid = viewingUserId || user.uid;
                const useCalendarStructure = !viewingUserId && activeCalendarId;

                // Fetch friend name if viewing a friend's calendar
                if (viewingUserId) {
                    const friendRef = doc(db, 'artifacts', appId, 'users', user.uid, 'friends', viewingUserId);
                    getDoc(friendRef).then(snap => {
                        if (snap.exists()) {
                            setViewingFriendName(snap.data().name || 'Friend');
                        }
                    }).catch(e => console.log("Friend name fetch error", e));
                } else {
                    setViewingFriendName(null);
                }

                try {
                    // Load events from calendar structure or fallback to user events
                    const u1 = useCalendarStructure 
                        ? onSnapshot(
                            collection(db, 'artifacts', appId, 'calendars', activeCalendarId, 'events'),
                            s => setEvents(s.docs.map(d => ({ id: d.id, ...d.data() }))),
                            e => { 
                                console.error(e); 
                                // Fallback to user events if calendar events fail
                                onSnapshot(
                                    collection(db, 'artifacts', appId, 'users', user.uid, 'events'),
                                    s => setEvents(s.docs.map(d => ({ id: d.id, ...d.data() }))),
                                    err => setUiError("Fehler beim Laden der Events.")
                                );
                            }
                          )
                        : onSnapshot(
                            collection(db, 'artifacts', appId, 'users', targetUid, 'events'), 
                            s => setEvents(s.docs.map(d => ({ id: d.id, ...d.data() }))),
                            e => { console.error(e); setUiError("Fehler beim Laden der Events. Datenbank pr√ºfen."); }
                          );
                    
                    const u2 = onSnapshot(collection(db, 'artifacts', appId, 'users', targetUid, 'shifts'), 
                        s => { if(!s.empty) setShifts(s.docs.map(d=>({id:d.id,...d.data()}))); },
                        e => console.error(e)
                    );
                    const u3 = onSnapshot(collection(db, 'artifacts', appId, 'users', targetUid, 'schedule'), 
                        s => { const sc={}; s.forEach(d=>sc[d.id]=d.data().shiftId); setSchedule(sc); },
                        e => console.error(e)
                    );
                    return () => { u1(); u2(); u3(); };
                } catch (e) { setUiError("Kritischer Fehler: " + e.message); }
            }, [user, viewingUserId, activeCalendarId]);

            // Fetch friend's name when viewing their calendar
            useEffect(() => {
                if (!viewingUserId) {
                    setViewingFriendName('');
                    return;
                }
                const fetchFriendName = async () => {
                    try {
                        // Try to get from profile first
                        const profileRef = doc(db, 'artifacts', appId, 'users', viewingUserId, 'profile', 'main');
                        const profileSnap = await getDoc(profileRef);
                        if (profileSnap.exists() && profileSnap.data().username) {
                            setViewingFriendName(profileSnap.data().username);
                            return;
                        }
                        // Try MSN profile
                        const msnProfileRef = doc(db, 'artifacts', appId, 'users', viewingUserId, 'secret_msn_profile', 'main');
                        const msnSnap = await getDoc(msnProfileRef);
                        if (msnSnap.exists() && msnSnap.data().username) {
                            setViewingFriendName(msnSnap.data().username);
                            return;
                        }
                        // Fallback to friend's shareCode
                        const friendRef = doc(db, 'artifacts', appId, 'users', user.uid, 'friends', viewingUserId);
                        const friendSnap = await getDoc(friendRef);
                        if (friendSnap.exists()) {
                            setViewingFriendName(friendSnap.data().shareCode || 'Freund');
                        } else {
                            setViewingFriendName('Freund');
                        }
                    } catch (e) {
                        console.error("Error fetching friend name", e);
                        setViewingFriendName('Freund');
                    }
                };
                fetchFriendName();
            }, [viewingUserId, user]);

                        
            const saveDisplayName = async (newNameRaw) => {
                if (!user) return;
                const newName = (newNameRaw || '').trim();
                if (!newName) return alert("Bitte einen Namen eingeben.");
                try {
                    const profileRef = doc(db, 'artifacts', appId, 'users', user.uid, 'profile', 'main');
                    await setDoc(profileRef, { name: newName }, { merge: true });
                    if (shareCode) {
                        await setDoc(doc(db, 'artifacts', appId, 'public_profiles', shareCode), { userId: user.uid, name: newName }, { merge: true });
                    }
                    // Update name in friends' documents (so existing friends see it too)
                    const myFriendsSnap = await getDocs(collection(db, 'artifacts', appId, 'users', user.uid, 'friends'));
                    const batch = writeBatch(db);
                    myFriendsSnap.forEach(fdoc => {
                        const fid = fdoc.id;
                        batch.set(doc(db, 'artifacts', appId, 'users', fid, 'friends', user.uid), { name: newName }, { merge: true });
                    });
                    await batch.commit();
                    setDisplayName(newName);
                    alert("Name gespeichert.");
                } catch (e) {
                    console.error("saveDisplayName error", e);
                    alert("Fehler beim Speichern des Namens.");
                }
            };

const addEvent = async (d, mode) => { 
                const { _occDate, _key, invitees, ...clean } = (d || {}); 
                const myName = ((displayName || '').trim() || getUserName(user));
                const targetFriendId = viewingUserId || null;
                const targetFriendName = viewingFriendName || 'Friend';

                // Mode normalisieren
                const m = (mode || (targetFriendId ? 'request' : 'self'));
                const wantsSelf = (m === 'self' || m === 'self_and_request');
                const wantsRequest = (m === 'request' || m === 'self_and_request') && !!targetFriendId;

                try {
                    // Build participants list from invitees or default behavior
                    // Note: The event creator (organizer) is always added with 'accepted' status
                    // because they are creating the event and implicitly accepting participation
                    let participants = [
                        { userId: user.uid, userName: myName, status: 'accepted' }
                    ];
                    
                    // Add invitees if provided
                    if (invitees && invitees.length > 0) {
                        invitees.forEach(inv => {
                            if (inv.userId) {
                                participants.push({ 
                                    userId: inv.userId, 
                                    userName: inv.userName, 
                                    status: inv.status || 'pending' 
                                });
                            }
                        });
                    } else if (wantsRequest) {
                        // Legacy behavior: add friend as participant
                        participants.push({ userId: targetFriendId, userName: targetFriendName, status: 'pending' });
                    }

                    const eventPayload = { ...clean, participants, createdBy: user.uid };

                    if (wantsSelf) {
                        // Use calendar structure if activeCalendarId exists, otherwise fallback to user events
                        if (activeCalendarId) {
                            await addDoc(collection(db, 'artifacts', appId, 'calendars', activeCalendarId, 'events'), eventPayload);
                        } else {
                            await addDoc(collection(db, 'artifacts', appId, 'users', user.uid, 'events'), eventPayload);
                        }
                    }

                    if (wantsRequest) {
                        await addDoc(collection(db, 'artifacts', appId, 'users', targetFriendId, 'pending_events'), {
                            ...eventPayload,
                            status: 'pending',
                            fromUserId: user.uid,
                            fromUserName: myName,
                            createdAt: serverTimestamp()
                        });
                        alert('Event-Anfrage an ' + (targetFriendName || 'Friend') + ' gesendet!');
                    }
                } catch (e) {
                    console.error("addEvent error", e);
                    alert("Fehler beim Speichern des Events.");
                }

                setShowEventModal(false); 
            };
            
            const updateEvent = async (d) => { 
                const { id, _occDate, _key, ...clean } = (d || {}); 
                try {
                    if (activeCalendarId) {
                        await updateDoc(doc(db, 'artifacts', appId, 'calendars', activeCalendarId, 'events', id), clean);
                    } else {
                        await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'events', id), clean);
                    }
                } catch (e) {
                    console.error("updateEvent error", e);
                    alert("Fehler beim Aktualisieren des Events.");
                }
                setSelectedEvent(null); 
            };
            
            const deleteEvent = async (id) => { 
                try {
                    if (activeCalendarId) {
                        await deleteDoc(doc(db, 'artifacts', appId, 'calendars', activeCalendarId, 'events', id));
                    } else {
                        await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'events', id));
                    }
                } catch (e) {
                    console.error("deleteEvent error", e);
                    alert("Fehler beim L√∂schen des Events.");
                }
                setSelectedEvent(null); 
            };
            
            const approvePendingEvent = async (pendingEventId) => {
                const pendingDoc = pendingEventRequests.find(e => e.id === pendingEventId);
                if (!pendingDoc) return;
                const { id, status, fromUserId, fromUserName, createdAt, ...eventData } = pendingDoc;
                
                // Update participant status for the approving user to 'accepted'
                let participants = eventData.participants || [];
                participants = participants.map(p => 
                    p.userId === user.uid ? { ...p, status: 'accepted' } : p
                );
                
                await addDoc(collection(db, 'artifacts', appId, 'users', user.uid, 'events'), {
                    ...eventData,
                    participants
                });
                await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'pending_events', pendingEventId), { status: 'approved' });
            };

            const rejectPendingEvent = async (pendingEventId) => {
                await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'pending_events', pendingEventId), { status: 'rejected' });
            };
            
            const updateParticipantStatus = async (eventId, userId, newStatus) => {
                const eventRef = doc(db, 'artifacts', appId, 'users', user.uid, 'events', eventId);
                const eventDoc = await getDoc(eventRef);
                if (!eventDoc.exists()) return;
                
                const eventData = eventDoc.data();
                const participants = eventData.participants || [];
                
                // Check if user exists in participants list
                const userExists = participants.some(p => p.userId === userId);
                if (!userExists) {
                    console.warn('User not found in participants list:', userId);
                    return;
                }
                
                const updatedParticipants = participants.map(p => 
                    p.userId === userId ? { ...p, status: newStatus } : p
                );
                
                await updateDoc(eventRef, { participants: updatedParticipants });
            };

            const assignShift = async (dateStr, sId) => { if(sId) await setDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'schedule', dateStr), { shiftId: sId }); else await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'schedule', dateStr)); };
            const clearShift = async (dateStr) => await assignShift(dateStr, null);
            // FIX: fehlende Funktionen, damit "Einstellungen" nicht abst√ºrzt
            const saveShiftConfig = async (shift) => {
                if (!user || !shift) return;
                const sid = shift.id || crypto.randomUUID();
                await setDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'shifts', sid), {
                    name: shift.name || 'Schicht',
                    start: shift.start || '06:00',
                    end: shift.end || '14:00',
                    color: shift.color || '#3b82f6'
                }, { merge: true });
            };

            const deleteShift = async (sid) => {
                if (!user || !sid) return;
                if (sid === 'off') return alert("Die Schicht 'Frei' kann nicht gel√∂scht werden.");
                try {
                    await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'shifts', sid));
                } catch (e) {
                    console.error(e);
                    alert("L√∂schen fehlgeschlagen.");
                }
            };

            // Calendar Management Functions
            const createCalendar = async (calendarData) => {
                if (!user) return;
                try {
                    const calendarId = generateCalendarId();
                    const newCalendar = {
                        name: calendarData.name || 'Neuer Kalender',
                        description: calendarData.description || '',
                        color: calendarData.color || '#3B82F6',
                        ownerId: user.uid,
                        members: [user.uid],
                        roles: {
                            [user.uid]: 'owner'
                        },
                        isPublic: false,
                        publicToken: null,
                        subscriptionToken: null,
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp()
                    };
                    
                    await setDoc(doc(db, 'artifacts', appId, 'calendars', calendarId), newCalendar);
                    setCalendars(prev => [...prev, { id: calendarId, ...newCalendar }]);
                    setActiveCalendarId(calendarId);
                    return calendarId;
                } catch (e) {
                    console.error("createCalendar error", e);
                    alert("Fehler beim Erstellen des Kalenders.");
                    return null;
                }
            };
            
            const updateCalendar = async (calendarId, updates) => {
                if (!user) return;
                try {
                    await updateDoc(doc(db, 'artifacts', appId, 'calendars', calendarId), {
                        ...updates,
                        updatedAt: serverTimestamp()
                    });
                    setCalendars(prev => prev.map(c => c.id === calendarId ? { ...c, ...updates } : c));
                } catch (e) {
                    console.error("updateCalendar error", e);
                    alert("Fehler beim Aktualisieren des Kalenders.");
                }
            };
            
            const shareCalendar = async (calendarId, userEmail, role = 'viewer') => {
                if (!user) return;
                try {
                    const calendar = calendars.find(c => c.id === calendarId);
                    if (!calendar) return alert(t('calendarNotFound'));
                    
                    // In a real app, you'd look up the user by email
                    // For now, we'll share by public link
                    alert(t('sharingRequiresEmailLookup'));
                } catch (e) {
                    console.error("shareCalendar error", e);
                    alert("Fehler beim Teilen des Kalenders.");
                }
            };
            
            const makeCalendarPublic = async (calendarId, isPublic) => {
                if (!user) return;
                try {
                    const calendar = calendars.find(c => c.id === calendarId);
                    if (!calendar) return alert(t('calendarNotFound'));
                    if (calendar.ownerId !== user.uid) return alert(t('onlyOwnerCanChangeSettings'));
                    
                    const publicToken = isPublic ? (calendar.publicToken || generateSecureToken()) : null;
                    const subscriptionToken = isPublic ? (calendar.subscriptionToken || generateSecureToken()) : null;
                    
                    await updateDoc(doc(db, 'artifacts', appId, 'calendars', calendarId), {
                        isPublic,
                        publicToken,
                        subscriptionToken,
                        updatedAt: serverTimestamp()
                    });
                    
                    setCalendars(prev => prev.map(c => 
                        c.id === calendarId ? { ...c, isPublic, publicToken, subscriptionToken } : c
                    ));
                } catch (e) {
                    console.error("makeCalendarPublic error", e);
                    alert("Fehler beim √Ñndern der Sichtbarkeit.");
                }
            };
            
            const exportCalendarICS = () => {
                if (!events || events.length === 0) {
                    alert(t('noEventsToExport'));
                    return;
                }
                
                const calendar = calendars.find(c => c.id === activeCalendarId);
                const calendarName = calendar ? calendar.name : 'TimeRoster Calendar';
                const icsContent = generateICS(events, calendarName);
                downloadICS(icsContent, `${calendarName.replace(/\s+/g, '_')}.ics`);
            };
            
            const getPublicLink = (calendarId) => {
                const calendar = calendars.find(c => c.id === calendarId);
                if (!calendar || !calendar.publicToken) return null;
                // In a real deployment, this would be the actual domain
                return `${window.location.origin}${window.location.pathname}?public=${calendar.publicToken}`;
            };
            
            const getSubscriptionLink = (calendarId) => {
                const calendar = calendars.find(c => c.id === calendarId);
                if (!calendar || !calendar.subscriptionToken) return null;
                // webcal:// protocol for calendar subscriptions
                const httpUrl = `${window.location.origin}${window.location.pathname}?ics=${calendar.subscriptionToken}`;
                return httpUrl.replace('http://', 'webcal://').replace('https://', 'webcal://');
            };


            const isComic = theme === 'comic';
            const isAmoled = theme === 'amoled';
            const isMono = theme === 'mono';
            const isNoble = theme === 'noble';
            const themeClasses = (() => {
                if (isComic) {
                    return {
                        input: 'bg-[#fdf6e3] border-[#8b5a2b] text-[#4a3b2a]',
                        select: 'bg-[#fdf6e3] border-[#8b5a2b] text-[#4a3b2a]',
                        button: 'bg-[#8b5a2b] text-[#f4e4bc] border-2 border-[#5c3a18]',
                        card: 'bg-[#e8d5a5] border-2 border-[#8b5a2b] shadow-lg text-[#4a3b2a]',
                        tabBar: 'bg-[#e8d5a5] border-t-4 border-[#8b5a2b]',
                        header: 'bg-[#e8d5a5] border-b-4 border-[#8b5a2b]',
                        listItem: 'bg-[#fdf6e3] border-b-2 border-[#d6c4a0]',
                        surfaceBtn: 'bg-[#e8d5a5] border border-[#8b5a2b]',
                        calendarHeader: 'bg-[#e8d5a5] border-b-4 border-[#8b5a2b]',
                        calendarToolbar: 'bg-[#f4e4bc]/60',
                        calendarWeek: 'bg-[#e8d5a5]',
                        calendarCell: 'bg-[#fdf6e3]',
                    };
                }
                if (isAmoled) {
                    return {
                        input: 'bg-black border-slate-800 text-white placeholder-slate-500',
                        select: 'bg-black border-slate-800 text-white',
                        button: 'bg-blue-600 hover:bg-blue-700 text-white',
                        card: 'bg-black border border-slate-800 shadow-xl text-white',
                        tabBar: 'bg-black border-t border-slate-800',
                        header: 'bg-black border-b border-slate-800',
                        listItem: 'bg-black border border-slate-800',
                        surfaceBtn: 'bg-black border border-slate-800',
                        calendarHeader: 'bg-black border-b border-slate-800',
                        calendarToolbar: 'bg-black/70 border-b border-slate-800',
                        calendarWeek: 'bg-black',
                        calendarCell: 'bg-black/70',
                    };
                }
                if (isMono) {
                    return {
                        input: 'bg-black border-white/20 text-white placeholder-white/40',
                        select: 'bg-black border-white/20 text-white',
                        button: 'bg-black text-white border border-white/25 hover:bg-white/10',
                        card: 'bg-black border border-white/15 shadow-xl text-white',
                        tabBar: 'bg-black border-t border-white/15',
                        header: 'bg-black border-b border-white/15',
                        listItem: 'bg-black border border-white/10',
                        surfaceBtn: 'bg-black border border-white/15',
                        calendarHeader: 'bg-black border-b border-white/15',
                        calendarToolbar: 'bg-black/70 border-b border-white/15',
                        calendarWeek: 'bg-black',
                        calendarCell: 'bg-black/70',
                    };
                }
                return {
                    input: 'bg-slate-100 border-slate-300 text-slate-900 placeholder-slate-400',
                    select: 'bg-slate-100 border-slate-300 text-slate-900',
                    button: 'bg-blue-500 hover:bg-blue-600 text-white',
                    card: 'bg-white border border-slate-200 shadow-lg text-slate-900',
                    tabBar: 'bg-slate-50 border-t border-slate-200',
                    header: 'bg-gradient-to-r from-blue-500 to-blue-600 border-b border-blue-700 text-white',
                    listItem: 'bg-slate-50 hover:bg-slate-100',
                    surfaceBtn: 'bg-slate-100 border border-slate-300',
                    calendarHeader: 'bg-gradient-to-r from-blue-500 to-blue-600 border-b border-blue-700 text-white',
                    calendarToolbar: 'bg-slate-100/80',
                    calendarWeek: 'bg-slate-50',
                    calendarCell: 'bg-white',
                };
            })();

            const refreshWeather = async ({ force = false, prefOverride = null } = {}) => {
                if (!navigator.onLine) {
                    setWeatherError("Offline ‚Äì Wetter nicht verf√ºgbar.");
                    return;
                }
                setWeatherError('');
                setWeatherLoading(true);
                try {
                    if (!force) {
                        const cachedRaw = localStorage.getItem(WEATHER_CACHE_KEY);
                        if (cachedRaw) {
                            const cached = JSON.parse(cachedRaw);
                            if (cached?.ts && (Date.now() - cached.ts) < WEATHER_CACHE_TTL_MS && cached?.weather) {
                                setWeather(cached.weather);
                                setWeatherLocation(cached.location || cached.weatherLocation || '');
                                setWeatherLoading(false);
                                return;
                            }
                        }
                    }

                    const pref = prefOverride || weatherPref || { mode: "geo", manual: null };

                    let coords = null;
                    if (pref.mode === "manual" && pref.manual?.lat && pref.manual?.lon) {
                        coords = { lat: pref.manual.lat, lon: pref.manual.lon, label: pref.manual.label || "Manuell" };
                    } else {
                        coords = await new Promise((resolve) => {
                            if (!navigator.geolocation) return resolve(DEFAULT_WEATHER_COORDS);
                            navigator.geolocation.getCurrentPosition(
                                (p) => resolve({ lat: p.coords.latitude, lon: p.coords.longitude, label: "Dein Standort" }),
                                () => resolve(DEFAULT_WEATHER_COORDS),
                                { enableHighAccuracy: false, timeout: 6000, maximumAge: WEATHER_CACHE_TTL_MS }
                            );
                        });
                    }
                    const url = buildWeatherUrl(coords.lat, coords.lon);
                    const res = await fetch(url);
                    if (!res.ok) throw new Error("HTTP " + res.status);
                    const data = await res.json();

                    const cur = data?.current || {};
                    const payload = {
                        temperature: cur.temperature_2m,
                        wind: cur.wind_speed_10m,
                        code: cur.weather_code,
                        time: cur.time,
                        lat: coords.lat,
                        lon: coords.lon
                    };

                    setWeather(payload);
                    setWeatherLocation(coords.label || "");

                    localStorage.setItem(WEATHER_CACHE_KEY, JSON.stringify({
                        ts: Date.now(),
                        location: coords.label || "",
                        weather: payload
                    }));
                } catch (e) {
                    console.error("Weather Error", e);
                    setWeatherError("Wetter aktuell nicht verf√ºgbar.");
                } finally {
                    setWeatherLoading(false);
                }
            };

            // Fetch 7-day weather forecast
            const fetch7DayForecast = async () => {
                setForecastLoading(true);
                try {
                    const coords = weather && weather.lat && weather.lon 
                        ? { lat: weather.lat, lon: weather.lon } 
                        : DEFAULT_WEATHER_COORDS;
                    
                    const params = new URLSearchParams({
                        latitude: String(coords.lat),
                        longitude: String(coords.lon),
                        daily: "temperature_2m_max,temperature_2m_min,weather_code,precipitation_sum,wind_speed_10m_max",
                        wind_speed_unit: "kmh",
                        temperature_unit: "celsius",
                        timezone: "Europe/Zurich"
                    });
                    const url = `https://api.open-meteo.com/v1/forecast?${params.toString()}`;
                    
                    const res = await fetch(url);
                    if (!res.ok) throw new Error("HTTP " + res.status);
                    const data = await res.json();
                    
                    setForecastData(data.daily);
                    setShowWeatherForecast(true);
                } catch (e) {
                    console.error("Forecast Error", e);
                    setWeatherError("Vorhersage aktuell nicht verf√ºgbar.");
                } finally {
                    setForecastLoading(false);
                }
            };

            // Handle secret messaging trigger with premium gate
            const handleSecretMessagesTrigger = () => {
                if (secretPremiumUnlocked) {
                    setShowSecret(true);
                } else {
                    setShowPremiumGate(true);
                }
            };

            // Load weather once after login (and keep cached)
            useEffect(() => {
                if (!user) return;
                refreshWeather({ force: false });
                // eslint-disable-next-line react-hooks/exhaustive-deps
            }, [user?.uid]);
            
            // Load saved weather preference (per user) from localStorage
            useEffect(() => {
                if (!user) return;
                try {
                    const raw = localStorage.getItem(getWeatherPrefKey(user.uid));
                    if (raw) setWeatherPref(JSON.parse(raw));
                } catch (e) { /* ignore */ }
            }, [user?.uid]);

            const saveWeatherPreference = (pref) => {
                if (!user) return;
                setWeatherPref(pref);
                try { localStorage.setItem(getWeatherPrefKey(user.uid), JSON.stringify(pref)); } catch(e) { /* ignore */ }
                refreshWeather({ force: true, prefOverride: pref });
            };




            
            const appShellClass = isComic
                ? 'bg-[#f4e4bc] text-[#4a3b2a]'
                : (isAmoled || isMono)
                    ? 'bg-black text-white'
                    : 'bg-slate-50 text-slate-900';
            if (!authChecked) return <div className="flex items-center justify-center min-h-screen bg-slate-100 text-slate-900"><div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div></div>;
            if (view === 'auth') return <AuthView setView={setView} />;

            return (
                <div className={`min-h-screen transition-colors duration-500 ${appShellClass} ${currentFont}`} style={{ fontSize: `${fontScale}em` }}>
                    {!showSecret && (
                        <div className={`sticky top-0 z-40 p-4 flex justify-between items-center ${themeClasses.header}`}>
                            <h1 className="text-xl font-bold">{viewingUserId ? t('viewing') : t(view)}</h1>
                            <button onClick={() => setView('settings')} className="p-2 rounded-lg hover:bg-white/5 active:scale-95" title="Einstellungen √∂ffnen"><Settings size={20}/></button>
                        </div>
                    )}

                    {/* Global Error Banner */}
                    {uiError && <div className="bg-red-600 text-white p-2 text-center text-xs font-bold">{uiError}</div>}

                    {viewingUserId && !showSecret && <div className="bg-orange-500 text-white p-2 text-center text-xs font-bold flex justify-between items-center px-4"><span>{t('viewing')}: {viewingFriendName || 'Freund'}</span><button onClick={() => setViewingUserId(null)} className="underline">{t('backToMe')}</button></div>}

                    {showSecret && <SecretMsnMessages user={user} onClose={() => setShowSecret(false)} />}

                    {!showSecret && (
                    <main className="pb-24 h-[calc(100vh-60px)] overflow-y-auto">
                        {view === 'dashboard' && (
                            <div className="p-4 space-y-6">
                                <div className={`p-6 rounded-2xl ${themeClasses.card}`}>
                                    
                                    <div className="flex items-start justify-between gap-3">
                                        <div className="min-w-0">
                                            <div className={`text-xs uppercase font-bold ${unreadMessageCount > 0 && dailyQuote.category === NOTIFICATION_INDICATOR_CATEGORY ? 'blink-red-notification' : 'opacity-60'}`}>
                                                {dailyQuote.category}
                                                {unreadMessageCount > 0 && dailyQuote.category === NOTIFICATION_INDICATOR_CATEGORY && (
                                                    <span className="ml-2 inline-flex items-center justify-center w-5 h-5 text-[10px] font-bold text-white bg-red-600 rounded-full">
                                                        {unreadMessageCount > 9 ? '9+' : unreadMessageCount}
                                                    </span>
                                                )}
                                            </div>
                                            <h2 className="text-xl font-bold leading-snug mt-1">{dailyQuote.text}</h2>
                                            <div className="text-xs opacity-60 mt-1">{dailyQuote.origin}</div>
                                        </div>
                                    </div>

                                    <div className="mt-4 flex items-center gap-2"><Briefcase size={16} className="opacity-70"/><span>{schedule[formatDate(new Date())] ? shifts.find(s=>s.id===schedule[formatDate(new Date())])?.name : "Frei"}</span></div>
                                    <div className="mt-4 p-3 rounded-xl bg-black/10 border border-white/5 flex items-center justify-between gap-3">
                                        <div 
                                            className="flex items-center gap-3 min-w-0 cursor-pointer hover:opacity-80 transition-opacity"
                                            onClick={() => weather && fetch7DayForecast()}
                                            title="Klicken f√ºr 7-Tage-Vorhersage"
                                        >
                                            <div className="text-2xl">
                                                {weatherLoading ? "‚è≥" : (weather ? getWeatherMeta(weather.code).icon : "üå°Ô∏è")}
                                            </div>
                                            <div className="min-w-0">
                                                <div className="font-bold truncate">
                                                    {weather ? `${Math.round(weather.temperature)}¬∞C ¬∑ ${getWeatherMeta(weather.code).label}` : (weatherError ? weatherError : "Wetter wird geladen‚Ä¶")}
                                                </div>
                                                <div className="text-xs opacity-70 truncate">
                                                    {weather ? `${weatherLocation || "Standort"} ¬∑ Wind ${Math.round(weather.wind || 0)} km/h` : "Open-Meteo"}
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div className="shrink-0 flex gap-2">
                                            <button
                                                onClick={() => setShowWeatherSettings(true)}
                                                className="px-3 py-2 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 text-xs font-bold"
                                                title="Ort ausw√§hlen"
                                            >
                                                Ort
                                            </button>
                                            <button
                                                onClick={() => refreshWeather({ force: true })}
                                                className="px-3 py-2 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 text-xs font-bold"
                                                title="Wetter aktualisieren"
                                            >
                                                Aktualisieren
                                            </button>
                                        </div>

                                    </div>

                                </div>
                                <button onClick={() => { setSelectedDate(new Date()); setShowEventModal(true); }} className={`w-full p-4 rounded-xl flex items-center justify-center gap-2 ${themeClasses.surfaceBtn}`}><Plus/> <span>{viewingUserId ? t('proposeEventForFriend') : t('newEvent')}</span></button>
                                
                                {pendingEventRequests.length > 0 && (
                                    <div className={`p-4 rounded-xl ${themeClasses.card} border-2 border-orange-500`}>
                                        <h3 className="font-bold mb-3 flex items-center gap-2 text-orange-400"><AlertCircle size={18}/> Event-Anfragen ({pendingEventRequests.length})</h3>
                                        <div className="space-y-3">
                                            {pendingEventRequests.map(req => (
                                                <div key={req.id} className={`p-3 rounded-lg ${isComic?'bg-[#fdf6e3]':'bg-black/20'}`}>
                                                    <div className="flex items-start justify-between gap-3 mb-2">
                                                        <div className="flex items-center gap-2 min-w-0">
                                                            <div className="text-2xl">{CATEGORIES.find(c=>c.id===req.category)?.icon}</div>
                                                            <div className="min-w-0">
                                                                <div className="font-bold truncate">{req.title || t(req.category)}</div>
                                                                <div className="text-xs opacity-70">von {req.fromUserName}</div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <div className="text-xs opacity-70 mb-3">{req.date} ¬∑ {req.time}</div>
                                                    <div className="flex gap-2">
                                                        <button onClick={() => approvePendingEvent(req.id)} className="flex-1 bg-green-600 text-white p-2 rounded text-xs font-bold">Annehmen</button>
                                                        <button onClick={() => rejectPendingEvent(req.id)} className="flex-1 bg-red-500/20 text-red-400 p-2 rounded text-xs font-bold">Ablehnen</button>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                <div className="space-y-3">
                                    <div className="flex items-center justify-between">
                                        <h3 className="font-bold">{t('upcoming')}</h3>
                                        <div className="flex items-center gap-1 text-[11px] bg-white/5 border border-white/10 rounded-lg p-1">
                                            <button onClick={() => setUpcomingRange('week')} className={`px-2 py-1 rounded-md ${upcomingRange==='week' ? 'bg-white/10 font-bold' : 'opacity-70 hover:opacity-100'}`}>{t('rangeWeek')}</button>
                                            <button onClick={() => setUpcomingRange('month')} className={`px-2 py-1 rounded-md ${upcomingRange==='month' ? 'bg-white/10 font-bold' : 'opacity-70 hover:opacity-100'}`}>{t('rangeMonth')}</button>
                                            <button onClick={() => setUpcomingRange('year')} className={`px-2 py-1 rounded-md ${upcomingRange==='year' ? 'bg-white/10 font-bold' : 'opacity-70 hover:opacity-100'}`}>{t('rangeYear')}</button>
                                        </div>
                                    </div>

                                    {upcomingItems.length === 0 && <p className="opacity-50 text-center py-4">{t('noUpcoming')}</p>}

                                    {upcomingItems.map(ev => (
                                        <div key={ev._key} onClick={() => setSelectedEvent(ev)} className={`p-4 rounded-xl flex items-center gap-4 cursor-pointer hover:opacity-80 ${isComic?'bg-[#fdf6e3] border-b-2 border-[#d6c4a0]':themeClasses.listItem}`}>
                                            <div className="text-2xl">{CATEGORIES.find(c=>c.id===ev.category)?.icon}</div>
                                            <div className="min-w-0">
                                                <div className="flex items-center justify-between gap-3">
                                                    <div className="font-bold truncate">{t(ev.category)}</div>
                                                    <div className="text-xs opacity-60 whitespace-nowrap">{ev._occDate}{ev.time ? ` ¬∑ ${ev.time}` : ''}</div>
                                                </div>
                                                <div className="text-sm opacity-70 truncate">{ev.title}</div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {view === 'calendar' && !showSearch && (
                            <div className="h-full flex flex-col">
                                {/* Calendar Selector Bar */}
                                {!viewingUserId && calendars.length > 0 && (
                                    <div className={`px-4 py-2 flex items-center gap-2 overflow-x-auto ${themeClasses.calendarHeader}`}>
                                        <select 
                                            value={activeCalendarId || ''}
                                            onChange={(e) => setActiveCalendarId(e.target.value)}
                                            className={`px-3 py-1.5 rounded-lg text-sm font-bold ${themeClasses.input}`}
                                        >
                                            {calendars.map(cal => (
                                                <option key={cal.id} value={cal.id}>
                                                    {cal.name}
                                                </option>
                                            ))}
                                        </select>
                                        <button 
                                            onClick={() => setShowCalendarManager(true)}
                                            className="p-1.5 rounded-lg bg-blue-600/20 text-blue-400 hover:bg-blue-600/30"
                                            title="Kalender verwalten"
                                        >
                                            <FolderPlus size={16}/>
                                        </button>
                                        <button 
                                            onClick={() => {
                                                const cal = calendars.find(c => c.id === activeCalendarId);
                                                if (cal) {
                                                    setSelectedCalendarForSettings(cal);
                                                    setShowCalendarSettings(true);
                                                }
                                            }}
                                            className="p-1.5 rounded-lg bg-blue-600/20 text-blue-400 hover:bg-blue-600/30"
                                            title="Kalender-Einstellungen"
                                        >
                                            <Share2 size={16}/>
                                        </button>
                                        <button 
                                            onClick={exportCalendarICS}
                                            className="p-1.5 rounded-lg bg-blue-600/20 text-blue-400 hover:bg-blue-600/30"
                                            title="Als ICS exportieren"
                                        >
                                            <Download size={16}/>
                                        </button>
                                    </div>
                                )}
                                
                                <div className={`flex items-center justify-between px-4 py-2 gap-2 ${themeClasses.calendarHeader}`}>
                                    <div className="flex gap-1 bg-black/20 rounded-lg p-1">
                                        <button onClick={() => setCalendarViewMode('day')} className={`px-3 py-1 rounded text-xs font-bold transition-all ${calendarViewMode === 'day' ? 'bg-blue-600 text-white' : 'opacity-60'}`}>{t('viewDay')}</button>
                                        <button onClick={() => setCalendarViewMode('week')} className={`px-3 py-1 rounded text-xs font-bold transition-all ${calendarViewMode === 'week' ? 'bg-blue-600 text-white' : 'opacity-60'}`}>{t('viewWeek')}</button>
                                        <button onClick={() => setCalendarViewMode('month')} className={`px-3 py-1 rounded text-xs font-bold transition-all ${calendarViewMode === 'month' ? 'bg-blue-600 text-white' : 'opacity-60'}`}>{t('viewMonth')}</button>
                                    </div>
                                    <button onClick={() => setShowSearch(true)} className="p-2 rounded-lg bg-blue-600/20 text-blue-400">
                                        <Search size={18}/>
                                    </button>
                                </div>
                                {calendarViewMode === 'month' && <CalendarView events={events} shifts={shifts} schedule={schedule} currentUserId={user?.uid || null} assignShift={assignShift} onDateClick={(date, event) => { setSelectedDate(date); if (event) setSelectedEvent(event); }} onDateLongPress={(date) => { setSelectedDate(date); setShowDayOptions(true); }} onSecretTrigger={handleSecretMessagesTrigger} viewingFriend={!!viewingUserId} viewingFriendName={viewingFriendName} themeClasses={themeClasses} isComic={isComic} secretPremiumUnlocked={secretPremiumUnlocked}/>}
                                {calendarViewMode === 'week' && <WeekView events={events} selectedDate={selectedDate} onDateClick={(date, event) => { setSelectedDate(date); if (event) setSelectedEvent(event); else setShowDayOptions(true); }} themeClasses={themeClasses} isComic={isComic}/>}
                                {calendarViewMode === 'day' && <DayView events={events} selectedDate={selectedDate} onDateClick={(date, event) => { setSelectedDate(date); if (event) setSelectedEvent(event); }} themeClasses={themeClasses} isComic={isComic}/>}
                            </div>
                        )}

                        {view === 'calendar' && showSearch && (
                            <div className="h-full flex flex-col pb-32">
                                <div className={`p-4 ${themeClasses.calendarHeader}`}>
                                    <div className="flex gap-2 items-center mb-4">
                                        <button onClick={() => { setShowSearch(false); setSearchQuery(''); }} className="p-2"><ArrowLeft /></button>
                                        <input
                                            type="text"
                                            value={searchQuery}
                                            onChange={(e) => setSearchQuery(e.target.value)}
                                            placeholder={t('searchPlaceholder')}
                                            className={`flex-1 p-3 rounded-lg outline-none ${themeClasses.input}`}
                                            autoFocus
                                        />
                                    </div>
                                    <div className="text-sm opacity-70">
                                        {searchResults.length > 0 ? `${searchResults.length} ${t('searchResults')}` : t('noResults')}
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto px-4 space-y-2">
                                    {searchResults.map((ev) => {
                                        const cat = CATEGORIES.find(c => c.id === ev.category);
                                        return (
                                            <div key={ev._key} 
                                                onClick={() => { setSelectedEvent(ev); setShowSearch(false); }}
                                                className={`p-4 rounded-xl cursor-pointer ${isComic ? 'bg-[#f4e4bc] border border-[#8b5a2b] text-[#4a3b2a]' : 'bg-slate-800'}`}>
                                                <div className="flex items-center gap-3">
                                                    <span className="text-2xl">{cat?.icon}</span>
                                                    <div className="flex-1">
                                                        <div className="font-bold">{ev.title}</div>
                                                        <div className="text-sm opacity-70 flex items-center gap-2">
                                                            <Clock size={14}/> {ev._occDate} um {ev.time}
                                                        </div>
                                                        {ev.location && <div className="text-xs opacity-60 flex items-center gap-1 mt-1"><MapPin size={12}/> {ev.location}</div>}
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        )}

                        {view === 'friends' && <FriendsView user={user} themeClasses={themeClasses} isComic={isComic} currentShareCode={shareCode} currentUserName={((displayName||'').trim()||getUserName(user))} onSelectFriend={(fid) => { setViewingUserId(fid); setView('calendar'); }}/>} 
                        {view === 'settings' && <SettingsView theme={theme} setTheme={setTheme} lang={lang} setLang={setLang} fontScale={fontScale} setFontScale={setFontScale} currentFont={currentFont} setCurrentFont={setCurrentFont} shifts={shifts} saveShiftConfig={saveShiftConfig} deleteShift={deleteShift} signOut={signOut} auth={auth} themeClasses={themeClasses} user={user} shareCode={shareCode} displayName={displayName} setDisplayName={setDisplayName} onSaveDisplayName={saveDisplayName}/>}
                    </main>
                    )}

                    {!showSecret && (
                        <nav className={`fixed bottom-0 w-full pb-safe pt-2 px-6 flex justify-between items-center z-50 ${themeClasses.tabBar}`}>
                            {[{id:'dashboard',icon:<Home/>,l:t('dashboard')},{id:'calendar',icon:<Calendar/>,l:t('calendar')},{id:'friends',icon:<Users/>,l:t('friends')},{id:'settings',icon:<Settings/>,l:t('settings')}].map(i => (
                                <button key={i.id} onClick={() => setView(i.id)} className={`flex flex-col items-center p-2 rounded-lg ${view===i.id?(isComic?'text-[#8b5a2b] font-bold scale-110':'text-blue-400'):'opacity-60'}`}>{i.icon}<span className="text-[10px] mt-1">{i.l}</span></button>
                            ))}
                        </nav>
                    )}

                    <EventModal show={showEventModal} onClose={()=>setShowEventModal(false)} onSave={addEvent} selectedDate={selectedDate} themeClasses={themeClasses} isComic={isComic} user={user} viewingFriendId={viewingUserId} viewingFriendName={viewingFriendName} currentUserName={((displayName||'').trim()||getUserName(user))}/>
                    <DayOptionsModal show={showDayOptions} onClose={()=>setShowDayOptions(false)} onAssignShift={assignShift} onClearShift={clearShift} onCreateEvent={()=>{setShowEventModal(true);}} selectedDate={selectedDate} shifts={shifts} themeClasses={themeClasses} isComic={isComic} viewingFriend={!!viewingUserId}/>
                    <EventDetailModal event={selectedEvent} onClose={()=>setSelectedEvent(null)} onSave={updateEvent} onDelete={deleteEvent} themeClasses={themeClasses} isComic={isComic} user={user} onUpdateParticipantStatus={updateParticipantStatus}/>

                    <WeatherLocationModal
                        show={showWeatherSettings}
                        onClose={() => setShowWeatherSettings(false)}
                        currentPref={weatherPref}
                        onSave={(pref) => { saveWeatherPreference(pref); setShowWeatherSettings(false); }}
                    />
                    
                    <WeatherForecastModal
                        show={showWeatherForecast}
                        onClose={() => setShowWeatherForecast(false)}
                        forecastData={forecastData}
                        weatherLocation={weatherLocation}
                    />
                    
                    <PremiumGateModal
                        show={showPremiumGate}
                        onClose={() => setShowPremiumGate(false)}
                        onUnlock={() => setSecretPremiumUnlocked(true)}
                    />
                    
                    <CalendarManagerModal
                        show={showCalendarManager}
                        onClose={() => setShowCalendarManager(false)}
                        calendars={calendars}
                        createCalendar={createCalendar}
                        themeClasses={themeClasses}
                        currentUserId={user?.uid}
                    />
                    
                    <CalendarSettingsModal
                        show={showCalendarSettings}
                        onClose={() => setShowCalendarSettings(false)}
                        calendar={selectedCalendarForSettings}
                        makePublic={makeCalendarPublic}
                        getPublicLink={getPublicLink}
                        getSubscriptionLink={getSubscriptionLink}
                        updateCalendar={updateCalendar}
                        themeClasses={themeClasses}
                    />

                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<TimeRosterApp />);
    </script>
</body>
</html>
